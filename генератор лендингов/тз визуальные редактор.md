**Полное техническое задание (ТЗ) на разработку визуального конструктора статических HTML-страниц**

**1. Общая информация**

*   **Название проекта:** Визуальный конструктор статических HTML-страниц (название можно уточнить).
*   **Цель:** Создание простого и удобного инструмента для формирования статических HTML-страниц из готовых элементов и блоков с возможностью редактирования содержимого и параметров, а также экспорта готовых страниц.
*   **Целевая аудитория:** Разработчики, не имеющие большого опыта в создании сайтов, или те, кто хочет быстро создать лендинг или простую страницу.

**2. Используемые технологии и библиотеки**

*   **Backend:**
    *   **Язык программирования:** PHP 8.1+
    *   **Фреймворк:** Laravel 11+
    *   **База данных:** MySQL 5.7+
    *   **Пакеты Laravel:**
        *   `laravel/framework`: Основной фреймворк Laravel.
        *   `intervention/image`: Для работы с изображениями (генерация превью), возможно входит в voyager.
        *   `spatie/laravel-medialibrary`: Для загрузки и хранения медиафайлов, возможно входит в voyager.
        *   `the-control-group/voyager`: Для админ-панели.
        *   `barryvdh/laravel-debugbar`: Для отладки (в режиме разработки).
        *   `spatie/laravel-html`: Для генерации HTML (если потребуется).
*   **Frontend:**
    *   **JavaScript-библиотеки:**
        *   `alpinejs`: Для создания интерактивности на странице.
        *   `interactjs`: Для реализации drag-and-drop функционала.
    *   **CSS Framework:**
        *   `tailwindcss`: Для стилизации компонентов и интерфейса.
    *   **Другие:**
        *   `axios` или `fetch`: Для отправки ajax запросов к API.
*   **Менеджер пакетов:**
    *   `composer`: для управления php зависимостями.
    *   `npm` или `yarn`: для управления javascript зависимостями.

**3. Функциональные требования**

**3.1. Административная панель (Voyager)**

*   **3.1.1. Управление страницами:**
    *   **Список страниц:**
        *   Отображение списка созданных страниц с возможностью поиска, сортировки и пагинации.
        *   Колонки: Название, URL, Дата создания/редактирования, Действия (Редактировать, Удалить).
    *   **Создание/Редактирование страницы:**
        *   Поле "Название" (обязательное).
        *   Поле "URL" (генерируется автоматически из названия, но можно редактировать).
        *   Поле "SEO заголовок" (опционально).
        *   Поле "SEO описание" (опционально).
        *   Поле "Ключевые слова" (опционально).
        *   Поле "Логотип" (загрузка файла, опционально).
        *   Текстовое поле "Пользовательские CSS классы" (опционально, для добавления классов на главный контейнер страницы).
        *   Текстовое поле "Пользовательский JS код" (опционально, для добавления js кода перед закрывающим тегом `</body>`).
        *   Выбор шрифта (выбор из списка добавленных в настройках).
         *   Выбор базового макета (layout).
        *   Кнопка "Редактировать страницу" (переход к визуальному редактору).
        *   Кнопка "Сохранить" (сохраняет параметры страницы).
        *   Кнопка "Удалить" (удаление страницы).
    *   **Удаление страниц:**
        *   Возможность удалять страницы (с подтверждением).

*   **3.1.2. Управление блоками:**
    *   **Список блоков:**
        *   Отображение списка всех добавленных блоков.
        *   Колонки: Название, Категория, Действия (Редактировать, Удалить).
        *   Поиск, сортировка, пагинация.
    *   **Создание/Редактирование блока:**
        *   Поле "Название" (обязательное).
        *   Выбор категории (из списка доступных).
        *   Текстовое поле "HTML-код блока" (обязательное, для вставки HTML кода блока).
         *  Поле "Превью блока" (загрузка изображения, генерируется или загружается).
        *   Кнопка "Сохранить".
        *   Кнопка "Удалить".
    *   **Удаление блоков:**
        *   Возможность удалять блоки (с подтверждением).

*   **3.1.3. Управление элементами:**
    *   **Список элементов:**
        *   Отображение списка всех добавленных элементов.
        *   Колонки: Название, Категория, Действия (Редактировать, Удалить).
        *   Поиск, сортировка, пагинация.
    *   **Создание/Редактирование элемента:**
        *   Поле "Название" (обязательное).
        *   Выбор категории (из списка доступных).
        *   Текстовое поле "HTML-код элемента" (обязательное, для вставки HTML кода элемента).
        *  Поле "Превью элемента" (загрузка изображения, генерируется или загружается).
        *   Кнопка "Сохранить".
        *   Кнопка "Удалить".
    *   **Удаление элементов:**
        *   Возможность удалять элементы (с подтверждением).

*   **3.1.4. Управление категориями:**
    *   **Список категорий:**
        *   Отображение списка всех созданных категорий.
        *   Колонки: Название, Действия (Редактировать, Удалить).
    *   **Создание/Редактирование категории:**
        *   Поле "Название" (обязательное).
        *   Кнопка "Сохранить".
        *   Кнопка "Удалить".
    *   **Удаление категорий:**
        *   Возможность удалять категории (с подтверждением).
        *   При удалении категории, все блоки и элементы, которые к ней относятся, должны получить значение "Без категории".

*   **3.1.5. Настройки системы:**
    *   Возможность добавлять и редактировать шрифты (в формате web шрифта).
    *   Возможность добавлять и редактировать css классы для всего сайта (например общие стили, которые можно нацеливать на любой элемент).
     *  Возможность вставлять код в `<head></head>` и `<footer></footer>` по умолчанию для всех страниц.

**3.2. Визуальный редактор (frontend)**

*   **3.2.1. Отображение страницы:**
    *   Отображение страницы.
    *   Отображение сетки для удобства редактирования, для вставки нового блока снизу.

*   **3.2.2. Панель готовых элементов и блоков:**
    *   Вкладка "Блоки":
        *   Отображение списка блоков сгруппированных по категориям.
        *   Превью блоков в виде миниатюр.
        *   Поиск по блокам.
        *   Перетаскивание блока на страницу (только в конец, под предыдущим блоком).
    *   Вкладка "Элементы":
        *   Отображение списка элементов сгруппированных по категориям.
        *   Превью элементов в виде миниатюр.
        *   Поиск по элементам.
        *   Перетаскивание элемента на страницу (внутрь блоков).

*   **3.2.3. Выделение элементов:**
    *   Выделение элемента при клике (визуальное отображение границ, рамка).
    *   При выделении элемента справа должно открываться окно редактора.

*   **3.2.4. Редактор элемента:**
    *   При выделении элемента (блока или элемента), открывается панель с настройками:
        *   **Блок:**
            *   Редактирование CSS-классов.
            *   Редактирование ID.
        *   **Элемент:**
            *   Редактирование CSS-классов.
            *   Редактирование ID.
            *   Редактирование текста (если он есть).
            *   Загрузка/изменение картинки (если он есть) или менять url картинки.
             * Простые стили (размер, цвет, жирный, курсив).
    *   Сохранение изменений элемента.

*   **3.2.5. Перетаскивание:**
    *   Возможность перетаскивания элементов внутри блоков (drag-and-drop).
    *   Перетаскивание блоков вниз страницы (drag-and-drop).
    * Режим перетаскивания блока или элемента включается в контесном меню.

*   **3.2.6. Контекстное меню (правый клик):**
    *   Клонировать элемент/блок.
    *   Удалить элемент/блок.
    *   Начать перемещение элемента/блока.

*   **3.2.7. Сохранение:**
    *   Кнопка "Сохранить" (сохраняет изменения страницы в базе данных через ajax запрос, без перезагрузки страницы).

*    **3.2.8. Просмотр:**
     *  Кнопка "Просмотр" (открывает страницу в новом окне без панелей редактора).
     *  Просмотр должен происходить по созданному лайоуту.

**3.3. Экспорт страницы:**

*   Кнопка "Экспорт" (генерирует HTML-файл страницы).
*   HTML файл, должен включать в себя верстку страницы со всеми изменениями и стилями, и все дополнительные css классы и скрипты.
*    Экспорт должен работать с учетом базового лайоута.
*   Скачивание HTML-файла.

**4. Технические детали**

*   **Структура проекта:**
    *   Стандартная структура Laravel.
    *   Структура Alpine.js.
    *   Все стили должны быть в `tailwind.css` и в custom стилях пользователя (которые он добавляет в админке).
*   **API:**
    *   Все запросы должны быть через API (REST) или ajax.
*   **Производительность:**
    *   Оптимизировать запросы к БД (использовать индексы).
    *   Минимизировать размер JS и CSS файлов.
    *   Использовать кэширование (если потребуется).

**5. Дополнительные требования**

*   **Язык интерфейса:** Русский.
*   **Адаптивность:** На первом этапе не требуется.
*   **История изменений:** На первом этапе не требуется, но желательно учесть возможность реализации в будущем.
*   **Шаблоны страниц:** На первом этапе не требуются, но желательно учесть возможность реализации в будущем.
*   **Работа с формами:** Не нужно реализовывать отдельно, формы будут как один из элементов.
*   **Интеграция с API:** Не требуется на первом этапе.
*   **Пользовательская аутентификация:** Не требуется на первом этапе (только для админки).
*   **Тестирование:** Обязательное модульное тестирование для backend и ручное тестирование для frontend.

**6. Процесс разработки**

1.  **Установка и настройка:**
    *   Установка Laravel.
    *   Установка Voyager.
    *   Настройка базы данных.
2.  **Создание моделей и миграций:**
    *   Создание моделей для страниц, блоков, элементов, категорий, шрифтов, лайоутов.
    *   Создание миграций.
3.  **Админ-панель:**
    *   Настройка Voyager для управления моделями.
4.  **Визуальный редактор:**
    *   Разработка HTML-структуры страницы.
    *   Подключение Alpine.js, tailwindcss.
    *   Реализация перетаскивания.
    *   Реализация выделения элементов.
    *   Разработка панели редактора.
    *   Сохранение через API.
5.  **Экспорт:**
    *   Генерация HTML.
6.  **Тестирование:**
    *   Проверка всего функционала.

**7. Передача проекта**

*   Должна быть документация по установке и настройке проекта.
*   Код должен быть чистым и понятным.
*   Должно быть модульное тестирование.

**8. Дополнительные нюансы**

*   **Превью:** Превью должны генерироваться на сервере при загрузке или добавлении блока или элемента. Возможно использовать `intervention/image` для генерации превью из HTML-кода или загружать картинку.
*   **Лайоуты:** Лайоуты могут храниться в базе данных или как blade шаблоны.
*   **Простые стили:** Для редактирования простых стилей использовать выпадающие списки, поля ввода и палитры цветов.
*   **Контекстное меню:** Реализовать на JavaScript с помощью библиотеки или без нее.

---
// resources/views/partials/media-manager.blade.php
<div x-show="Alpine.store('mediaManager').show" 
     class="fixed z-50 inset-0 overflow-y-auto bg-gray-500 bg-opacity-75 flex items-center justify-center"  style="display: none;">
    <div class="bg-white rounded-lg p-8 w-3/4 max-w-3xl" x-data="mediaManagerData()" x-init="init()">
        <h2 class="text-2xl font-bold mb-4">Медиа-менеджер</h2>
        <div class="mb-4">
            <input type="file" @change="uploadImage($event)">
        </div>
        <div class="grid grid-cols-4 gap-4">
            <template x-for="image in images" :key="image">
                <div class="border p-2 cursor-pointer" 
                     :class="{'border-blue-500': selectedImage === image}"
                     @click="selectImage(image)">
                    <img :src="image" alt="" class="w-full h-32 object-cover">
                </div>
            </template>
        </div>
        <div class="flex justify-end mt-4">
            <button @click="confirmSelection()" 
                    :disabled="!selectedImage"
                    class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded mr-2 disabled:opacity-50 disabled:cursor-not-allowed">
                Выбрать
            </button>
            <button @click="Alpine.store('mediaManager').show = false" 
                    class="bg-gray-300 hover:bg-gray-400 text-gray-700 font-bold py-2 px-4 rounded">
                Отмена
            </button>
        </div>
    </div>
</div>

// app/Http/Controllers/BlockController.php
<?php

namespace App\Http\Controllers;

use App\Models\Block;
use Illuminate\Support\Str;
use Illuminate\Http\Request;
use Symfony\Component\DomCrawler\Crawler;


class BlockController extends Controller
{
    public function show(Block $block)
    {
        $html = $block->html_code;

        // Инициализация Crawler
        $crawler = new Crawler($html);

        // Определяем теги, к которым нужно добавить атрибуты
        $tags = ['button', 'a', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'span', 'img', 'div', 'input', 'form', 'li', 'ul', 'ol', 'dt', 'dd'];

        foreach ($tags as $tag) {
            $crawler->filter($tag)->each(function (Crawler $node) {
                // Генерируем уникальный ID
                $id = (string) Str::uuid();
                $domNode = $node->getNode(0);

                $domNode->setAttribute('data-id', $id);
                $domNode->setAttribute('data-type', 'element');

                // Устанавливаем атрибут ID, если он не задан
                if (!$domNode->hasAttribute('id')) {
                    $domNode->setAttribute('id', 'element-' . $id);
                }
            });
        }

        // Получаем модифицированный HTML
        $modifiedHtml = $crawler->html();

        return response()->json([
            'html_code' => $modifiedHtml,
            'preview' => $block->preview ? asset('storage/' . $block->preview) : null,
            'type' => $block->type,
        ]);
    }
}

// app/Http/Controllers/EditorController.php
<?php

namespace App\Http\Controllers;

use App\Models\Template;
use App\Models\PageBuild;
use Illuminate\Support\Str;
use Illuminate\Http\Request;
use App\Models\CategoryBlock;
use Symfony\Component\DomCrawler\Crawler;

class EditorController extends Controller
{
    public function show(PageBuild $page)
    {
        $categories = CategoryBlock::with(['blocks'])->get();
        // Добавляем атрибуты к контенту страницы
        $page->content = $page->addAttributesToContent($page->content);
        $templates = Template::all(); // Получаем все шаблоны из базы данных
        return view('editor', ['page' => $page, 'categories' => $categories, 'templates' => $templates]);
    }

    public function savePage(Request $request, PageBuild $page)
    {
        // Валидация данных
        $validated = $request->validate([
            'content' => 'required|string',
            // Добавьте другие необходимые поля
        ]);

        // Преобразуем контент без обёртки в `<!DOCTYPE html><html><body>`
        $cleanContent = $this->cleanHtmlContent($validated['content']);
        $validated['content'] = $cleanContent;

        $page->update($validated);

        return response()->json(['message' => 'Страница успешно сохранена', 'content' => $page->content]);
    }

    private function cleanHtmlContent($html)
    {
        $crawler = new Crawler($html);

        // Получаем содержимое body без обёртки в теги html и body
        $bodyHtml = '';
        foreach ($crawler->filter('body')->children() as $domElement) {
            $bodyHtml .= $crawler->outerHtml($domElement);
        }

        return $bodyHtml;
    }


}

// app/Http/Controllers/ElementController.php
<?php

namespace App\Http\Controllers;

use App\Models\Element;
use Illuminate\Support\Str;
use Illuminate\Http\Request;

class ElementController extends Controller
{
    public function show(Element $element)
    {
        $html = $element->html_code;

        // Инициализация DOMDocument
        $dom = new \DOMDocument();
        libxml_use_internal_errors(true);
        $dom->loadHTML(mb_convert_encoding($html, 'HTML-ENTITIES', 'UTF-8'));
        libxml_clear_errors();

        $xpath = new \DOMXPath($dom);

        // Определяем теги, к которым нужно добавить атрибуты
        $tags = ['button', 'a', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'span', 'img','div', 'input','form','li','ul','ol','dt','dd'];

        foreach ($tags as $tag) {
            $elements = $xpath->query("//{$tag}");
            foreach ($elements as $elementitem) {
                if ($elementitem instanceof \DOMElement) {
                    // Генерируем уникальный ID
                    $id = (string) Str::uuid();
                    $elementitem->setAttribute('data-id', $id);
                    $elementitem->setAttribute('data-type', 'element');

                    // Устанавливаем атрибут ID, если он не задан
                    if (!$elementitem->hasAttribute('id')) {
                        $elementitem->setAttribute('id', 'element-' . $id);
                    }
                }
            }
        }

        // Получаем содержимое body без тегов <html>, <head> и <body>
        $body = $dom->getElementsByTagName('body')->item(0);
        $innerHTML = '';
        foreach ($body->childNodes as $child) {
            $innerHTML .= $dom->saveHTML($child);
        }

        return response()->json([
            'html_code' => $innerHTML,
            'preview' => $element->preview ? asset('storage/' . $element->preview) : null
        ]);
    }
}

// app/Http/Controllers/ImageController.php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Intervention\Image\Facades\Image;
use Illuminate\Support\Facades\Storage;


class ImageController extends Controller
{
    public function upload(Request $request)
    {
        $request->validate([
            'image' => 'required|image|max:2048', // Ограничение на размер и тип изображения
        ]);

        $image = $request->file('image');
        $filename = time() . '_' . $image->getClientOriginalName();
        $path = $image->storeAs('images', $filename, 'public');

        // Генерация превью, если необходимо
        // $previewPath = 'previews/' . $filename;
        // Image::make($image)->resize(50, 50)->save(storage_path('app/public/' . $previewPath));

        return response()->json(['url' => asset('storage/' . $path)]);
    }

    public function index() {
        $files = Storage::disk('public')->files('images');
        $images = array_map(function($file) {
            return asset('storage/' . $file);
        }, $files);
        
        return response()->json([
            'images' => $images
        ]);
    }
}

// app/Http/Controllers/PageBuildController.php
<?php

namespace App\Http\Controllers;

use App\Models\PageBuild;
use Illuminate\Http\Request;
use Symfony\Component\DomCrawler\Crawler;


class PageBuildController extends Controller
{
    public function update(Request $request, PageBuild $page)
    {
        $validated = $request->validate([
            'content' => 'nullable|string',
        ]);
        $page->update($validated);
        return response()->json(['message' => 'Страница успешно обновлена']);
    }

    public function preview(PageBuild $page)
    {
        $processedContent = $this->removeEditorAttributes($page->content);
        return view('preview', ['page' => $page, 'processedContent' => $processedContent]);
    }

    public function export(PageBuild $page)
    {
        $processedContent = $this->removeEditorAttributes($page->content);

        // Генерируем HTML содержимое через Blade шаблон
        $htmlContent = view('export', ['page' => $page, 'processedContent' => $processedContent])->render();

        // Создаем временный файл для экспорта
        $filename = $page->url . '.html';
        $path = storage_path('app/public/exports/' . $filename);
        file_put_contents($path, $htmlContent);

        return response()->download($path)->deleteFileAfterSend(true);
    }

    private function removeEditorAttributes($htmlContent)
    {
        // Оборачиваем контент в корневой элемент, чтобы избежать проблем с несколькими корневыми элементами
        $html = '<div id="tmp-root">' . $htmlContent . '</div>';
    
        $crawler = new \Symfony\Component\DomCrawler\Crawler($html);
    
        // Удаляем все атрибуты data-id и data-type из всех элементов
        foreach ($crawler->filter('[data-id], [data-type]') as $domElement) {
            /** @var \DOMElement $domElement */
            $domElement->removeAttribute('data-id');
            $domElement->removeAttribute('data-type');
        }
    
        // Получаем HTML-код элемента с id="tmp-root"
        $innerHTML = '';
        foreach ($crawler->filter('#tmp-root') as $domElement) {
            /** @var \DOMElement $domElement */
            // Получаем все дочерние узлы
            foreach ($domElement->childNodes as $child) {
                $innerHTML .= $domElement->ownerDocument->saveHTML($child);
            }
        }
    
        return $innerHTML;
    }

}

// app/Http/Controllers/TemplateController.php
<?php
namespace App\Http\Controllers;

use App\Models\Template;
use Illuminate\Http\Request;

class TemplateController extends Controller
{
    /**
     * Отображает список всех шаблонов.
     */
    public function index()
    {
        $templates = Template::all();
        return view('templates.index', compact('templates'));
    }

    /**
     * Отображает форму для создания нового шаблона.
     */
    public function create()
    {
        return view('templates.create');
    }

    /**
     * Сохраняет новый шаблон в базе данных.
     */
    public function store(Request $request)
    {
        $request->validate([
            'name' => 'required|string|max:255',
            'content' => 'required|string',
        ]);

        Template::create([
            'name' => $request->name,
            'content' => $request->content,
        ]);

        return response()->json(['message' => 'Шаблон успешно сохранен']);
    }

    /**
     * Отображает форму для редактирования шаблона.
     */
    public function edit(Template $template)
    {
        return view('templates.edit', compact('template'));
    }

    /**
     * Обновляет шаблон в базе данных.
     */
    public function update(Request $request, Template $template)
    {
        $request->validate([
            'name' => 'required|string|max:255',
            'content' => 'required|string',
        ]);

        $template->update([
            'name' => $request->name,
            'content' => $request->content,
        ]);

        return redirect()->route('templates.index')->with('success', 'Шаблон успешно обновлен!');
    }

    /**
     * Удаляет шаблон из базы данных.
     */
    public function destroy(Template $template)
    {
        $template->delete();
        return redirect()->route('templates.index')->with('success', 'Шаблон успешно удален!');
    }

    /**
     * Возвращает содержимое шаблона для применения.
     */
    public function show(Template $template)
    {
        return response()->json([
            'content' => $template->content,
        ]);
    }
}

// app/Models/Block.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Block extends Model
{
    use HasFactory;

    protected $fillable = [
        'title',
        'category_id',
        'html_code',
        'preview',
        'type', // Добавили поле 'type'
    ];

    protected $attributes = [
        'type' => 'block', // Дефолтное значение
    ];

    public function category()
    {
        return $this->belongsTo(CategoryBlock::class, 'category_id');
    }
}

// app/Models/CategoryBlock.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class CategoryBlock extends Model
{
    use HasFactory;

    protected $fillable = [
        'title'
    ];

    public function blocks()
    {
        return $this->hasMany(Block::class, 'category_id');
    }
    
    // Если нужна фильтрация по типу, можно добавить методы:
    
    public function elements()
    {
        return $this->blocks()->where('type', 'element');
    }
    
    public function onlyBlocks()
    {
        return $this->blocks()->where('type', 'block');
    }
}

// app/Models/PageBuild.php
<?php

namespace App\Models;

use Illuminate\Support\Str;
use Illuminate\Database\Eloquent\Model;
use App\Http\Controllers\EditorController;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Symfony\Component\DomCrawler\Crawler;

class PageBuild extends Model
{
    use HasFactory;

    protected $fillable = [
       'title',
       'url',
       'seo_title',
       'seo_description',
       'keywords',
       'logo',
       'custom_css_classes',
       'custom_js_code',
        'font_id',
       'layout_id',
       'content',
   ];


   public function font()
   {
       return $this->belongsTo(Font::class);
   }

   public function layout()
   {
       return $this->belongsTo(Layout::class);
   }
   protected static function boot()
  {
      parent::boot();

      static::updating(function ($page) {
          // Если контент изменился, то генерируем data-id и data-type
          if ($page->isDirty('content')) {
              $page->content = $page->addAttributesToContent($page->content);
          }
      });
  }


  public function addAttributesToContent($content = "")
  {
      if (empty($content)) {
          return "";
      }

      $crawler = new Crawler($content);

      // Обрабатываем блоки
      $this->processElements($crawler, '[class*="block-"]', 'block');

      // Обрабатываем элементы внутри блоков
      $this->processElements($crawler, '[class*="element-"]', 'element');

      // Получаем модифицированный HTML
      return $crawler->html();
  }

  protected function processElements(Crawler $crawler, string $selector, string $type)
  {
      $crawler->filter($selector)->each(function (Crawler $node) use ($type) {
          $domNode = $node->getNode(0);
          if ($domNode instanceof \DOMElement) {
              $id = (string) Str::uuid();
              $domNode->setAttribute('data-id', $id);
              $domNode->setAttribute('data-type', $type);
              if (!$domNode->hasAttribute('id')) {
                  $domNode->setAttribute('id', ($type === 'block' ? 'block-' : 'element-') . $id);
              }

              // Добавляем data-parallax-strength, если установлен параллакс
              if ($domNode->hasAttribute('data-parallax-strength')) {
                  $strength = $domNode->getAttribute('data-parallax-strength');
                  $domNode->setAttribute('data-parallax-strength', $strength);
              }
          }
      });
  }
}

// app/Models/Template.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class Template extends Model
{
    use HasFactory;

    protected $fillable = [
       'name',
       'content',

   ];
}

// resources/js/app.js
import { v4 as uuidv4 } from 'uuid';
import './bootstrap';
import Alpine from 'alpinejs';
import  elementEditor  from './components/element-editor';
import blockComponent from './components/block-component';
import elementComponent from './components/element-component';
import editor from './components/editor'; 
import mediaManager from './components/media-manager';

window.Alpine = Alpine;



// Регистрируем стор для медиа-менеджера
Alpine.store('mediaManager', {
    show: false,
    images: [],
    selectedImage: null
});

Alpine.data('mediaManagerData', mediaManager);

Alpine.data('editor', editor);
Alpine.data('elementEditor', elementEditor);

// Создаём глобальный стор "editorStore"
Alpine.store('editorStore', {
    selectedElement: {
        type: null,
        id: null,
        tag: null,
        cssClasses: null,
        text: null,
        imageUrl: null,
        isText: null,
        isImage: null,
        elementId: null,
        textColor: '#ffffff',
        elementBackgroundColor: '#ffffff',
        elementBackgroundSize: 'bg-cover',
        elementBackgroundPosition: 'bg-center',
        textSize: null,
        isBold: null,
        isItalic: null,
        blockCssClasses: null,
        blockId: null,
        elementCssClasses: null,
        elementText: null,
        elementImageUrl: null,
        elementTextColor: '#ffffff',
        elementTextSize: null,
        parallaxStrength: 5,
        href: null,
                // ... существующие свойства ...
                lightboxEnabled: false,
                lightboxImageUrl: '',
    },
    modalCode: null,
    showModal: false,
    showPanel: false,
    // любые другие поля
  });

Alpine.data('blockComponent', blockComponent);
Alpine.data('elementComponent', elementComponent);

Alpine.start();

// resources/js/components/media-manager.js
import axios from 'axios';

export default () => ({
    show: false,
    images: [],
    selectedImage: null,
    init() {
        this.loadImages();
    },
    loadImages() {
        axios.get('/media/images')
            .then(response => {
                this.images = response.data.images;
            })
            .catch(error => {
                console.error('Ошибка при загрузке изображений:', error);
            });
    },
    uploadImage(event) {
        const file = event.target.files[0];
        if (file) {
            const formData = new FormData();
            formData.append('image', file);

            axios.post('/media/upload', formData, {
                headers: {
                    'Content-Type': 'multipart/form-data'
                }
            })
            .then(response => {
                // Добавляем новое изображение в список
                this.images.push(response.data.url);
            })
            .catch(error => {
                console.error('Ошибка загрузки изображения:', error);
            });
        }
    },
    selectImage(image) {
        this.selectedImage = image;
    },
    confirmSelection() {
        this.$dispatch('image-selected', { imageUrl: this.selectedImage });
        this.show = false;
    }
});

// resources/js/components/element-editor.js
import axios from 'axios';
import common from './common';
import { v4 as uuidv4 } from 'uuid';
export default () => ({
    ...common(), // Включаем общие методы
    //blockCssClasses: '',
    //blockId: '',
    //elementCssClasses: '',
    //elementId: '',
    //elementText: '',
    //elementImageUrl: '',
    //elementBackgroundColor: '#ffffff',
    //elementBackgroundUrl: '',
    //elementTextColor: '#000000',
    //elementTextSize: 16,
    //elementParallax: false,
    get selectedElement() {
        return Alpine.store('editorStore').selectedElement;
    },
    set selectedElement(val) {
        Alpine.store('editorStore').selectedElement = val;
    },
    get showModal() {
        return Alpine.store('editorStore').showModal;
    },
    set showModal(val){
        Alpine.store('editorStore').showModal = val;
    },
    get modalCode() {
        return Alpine.store('editorStore').modalCode;
    },
    set modalCode(val){
        Alpine.store('editorStore').modalCode = val;
    },

    get showPanel() {
        return Alpine.store('editorStore').showPanel;
    },
    set showPanel(val) {
        Alpine.store('editorStore').showPanel = val;
    },
    init() {
        console.log('init element editor');
    },

    /**
     * Применяет HTML-код из модального окна к выбранному элементу.
     */
    applyCode() {
        console.log('applyCode');
        console.log('Selected Element:', this.selectedElement);
        const element = document.querySelector(`[data-id="${this.selectedElement.elementId}"]`);
        console.log('element:', element);

        if (element) {
            // Создаём временный контейнер и помещаем в него новый HTML-код
            const tempContainer = document.createElement('div');
            tempContainer.innerHTML = this.modalCode;

            // Рекурсивно обходим все элементы и добавляем атрибуты
            this.addAttributesRecursively(tempContainer);

            // Заменяем содержимое элемента на модифицированный код из временного контейнера
            element.outerHTML = tempContainer.innerHTML;

            this.$nextTick(() => {
                this.updateElementContent();
            });
        } else {
            console.log('Element not found with data-id:', this.selectedElement.elementId);
        }

        this.showModal = false;
        this.modalCode = '';
    },

    /**
     * Рекурсивно обходит все дочерние элементы и добавляет к ним необходимые атрибуты.
     * @param {HTMLElement} element - Элемент, который нужно обработать.
     */
    addAttributesRecursively(element) {
        const forbiddenTags = ['SCRIPT'];
        // Перебираем все дочерние элементы
        for (let child of element.children) {
          if (forbiddenTags.includes(child.tagName)) {
              continue; // Пропускаем запрещённые теги
          }
            // Если у элемента нет атрибута data-id, добавляем его
            if (!child.hasAttribute('data-id')) {
                const id = uuidv4();
                child.setAttribute('data-id', id);
                child.setAttribute('data-type', 'element');
                child.setAttribute('id', 'element-' + id);
            }

            // Рекурсивно вызываем функцию для всех дочерних элементов
            this.addAttributesRecursively(child);
        }
    },
    updateHref() {
        const element = document.getElementById(this.selectedElement.id);
        if (element && this.selectedElement.href) {
            element.setAttribute('href', this.selectedElement.href);
            this.dispatchUpdatePage();
        }
    },
    updateTarget() {
        const element = document.getElementById(this.selectedElement.id);
        if (element && this.selectedElement.target) {
            element.setAttribute('target', this.selectedElement.target);
            this.dispatchUpdatePage();
        }
    },
    updateHeader() {
        const element = document.getElementById(this.selectedElement.id);
        if (element && this.selectedElement.tag && ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'].includes(this.selectedElement.tag)) {
            const newElement = document.createElement(this.selectedElement.tag);
    
            // Копируем все атрибуты
            Array.from(element.attributes).forEach(attr => {
                newElement.setAttribute(attr.name, attr.value);
            });
    
            // Копируем все классы
            newElement.className = element.className;
    
            // Копируем содержимое
            newElement.innerHTML = element.innerHTML;
    
            // Заменяем старый элемент новым
            element.parentNode.replaceChild(newElement, element);
    
            // Обновляем selectedElement
            this.selectedElement.id = newElement.id;
            this.dispatchUpdatePage();
        }
    },


    applyParallaxStyle() {
        console.log('applyParallaxStyle')
        const element = document.getElementById(this.selectedElement.id);
        if (element) {
            element.style.backgroundAttachment = this.selectedElement.elementParallax ? 'fixed' : 'scroll';
            this.$dispatch('update-page');
        }
    },
    removeBackgroundImage() {
        console.log('removeBackgroundImage');
        this.selectedElement.elementBackgroundUrl = '';
        this.selectedElement.elementBackgroundColor = '#ffffff'; // Устанавливаем цвет фона по умолчанию
        this.applyBackgroundStyle('background-image', 'none');
    },
    /**
     * Обработка изменения изображения элемента.
     * @param {Event} event - Событие изменения файла.
     */
    handleImageChange(event) {
        console.log('handleImageChange');
        // Открываем медиа-менеджер
        Alpine.store('mediaManager').show = true;
    
        // Слушаем событие выбора изображения
        this.$root.addEventListener('image-selected', (e) => {
            this.selectedElement.elementImageUrl = e.detail.imageUrl;
            this.applyStyle('src', this.selectedElement.elementImageUrl);
            Alpine.store('mediaManager').show = false;
        }, { once: true });
    },
    openMediaManager() {
        Alpine.store('mediaManager').show = true;
    
        // Слушаем событие выбора изображения
        this.$root.addEventListener('image-selected', (e) => {
            this.selectedElement.elementImageUrl = e.detail.imageUrl;
            this.applyStyle('src', this.selectedElement.elementImageUrl);
            Alpine.store('mediaManager').show = false;
        }, { once: true });
    },
    openMediaManagerForBackground() {
        Alpine.store('mediaManager').show = true;
    
        this.$root.addEventListener('image-selected', (e) => {
            this.selectedElement.elementBackgroundUrl = e.detail.imageUrl;
            this.applyBackgroundStyle('background-image', `url('${this.selectedElement.elementBackgroundUrl}')`);
            Alpine.store('mediaManager').show = false;
        }, { once: true });
        
    },
    openMediaManagerForLightbox() {
        Alpine.store('mediaManager').show = true;

        // Слушаем событие выбора изображения
        this.$root.addEventListener('image-selected', (e) => {
            this.selectedElement.lightboxImageUrl = e.detail.imageUrl;
            this.updateLightboxImageUrl();
            Alpine.store('mediaManager').show = false;
        }, { once: true });
    },
    /**
     * Обработка изменения фона элемента.
     * @param {Event} event - Событие изменения файла.
     */
    handleBackgroundChange(event) {
        console.log('handleBackgroundChange');
        const file = event.target.files[0];
        if (file) {
            const formData = new FormData();
            formData.append('image', file);

            axios.post('/admin/upload-image', formData, {
                headers: {
                    'Content-Type': 'multipart/form-data'
                }
            })
            .then(response => {
                this.selectedElement.elementBackgroundUrl = response.data.url;
                this.applyBackgroundStyle('background-image', `url('${this.selectedElement.elementBackgroundUrl}')`);
            })
            .catch(error => {
                console.error('Ошибка загрузки изображения:', error);
            });
        }
    },

    /**
     * Переключает текстовые стили (жирный, курсив).
     * @param {string} style - Название стиля ('bold' или 'italic').
     */
    toggleStyle(style) {
        const element = document.getElementById(this.selectedElement.id);
        if (!element) return;
    
        const styleMap = {
            "underline": "underline",
            "overline": "overline",
            "line-through": "line-through",
            "no-underline": "no-underline"
        }
    
        if (style in styleMap) {
            element.classList.toggle(styleMap[style]);
            this.selectedElement[`is${style.charAt(0).toUpperCase() + style.slice(1)}`] = !this.selectedElement[`is${style.charAt(0).toUpperCase() + style.slice(1)}`];
        }
    
        this.dispatchUpdatePage();
    },
    toggleTextClass() {
        const element = document.getElementById(this.selectedElement.id);
        if (element) {
            ['text-xs', 'text-sm', 'text-base', 'text-lg', 'text-xl', 'text-2xl', 'text-3xl', 'text-4xl', 'text-5xl', 'text-6xl', 'text-7xl', 'text-8xl', 'text-9xl'].forEach(cls => {
                element.classList.remove(cls);
            });
            element.classList.add(this.selectedElement.textClass);
            this.dispatchUpdatePage();
        }
    },
    toggleAlignment(alignment) {
        const element = document.getElementById(this.selectedElement.id);
        if (element) {
            ['text-left', 'text-center', 'text-right', 'text-justify'].forEach(cls => {
                element.classList.remove(cls);
            });
            element.classList.add(alignment);
            this.dispatchUpdatePage();
        }
    },
    toggleTextFont() {
        const element = document.getElementById(this.selectedElement.id);
        if (element) {
            ['font-thin', 'font-extralight', 'font-light', 'font-normal', 'font-medium', 'font-semibold', 'font-bold', 'font-extrabold', 'font-black'].forEach(cls => {
                element.classList.remove(cls);
            });
            element.classList.add(this.selectedElement.textFont);
            this.dispatchUpdatePage();
        }
    },
    applyBackgroundRepeat() {
        const element = document.getElementById(this.selectedElement.id);
        if (element) {
            ['bg-repeat', 'bg-no-repeat', 'bg-repeat-x', 'bg-repeat-y', 'bg-repeat-round', 'bg-repeat-space'].forEach(cls => {
                element.classList.remove(cls);
            });
            element.classList.add(this.selectedElement.backgroundRepeat);
            this.dispatchUpdatePage();
        }
    },
    applyBackgroundSize() {
        const element = document.getElementById(this.selectedElement.id);
        if (element) {
            ['bg-auto', 'bg-cover', 'bg-contain'].forEach(cls => {
                element.classList.remove(cls);
            });
            element.classList.add(this.selectedElement.backgroundSize);
            this.dispatchUpdatePage();
        }
    },
    applyBackgroundAttachment() {
        const element = document.getElementById(this.selectedElement.id);
        if (element) {
            ['bg-fixed', 'bg-local', 'bg-scroll'].forEach(cls => {
                element.classList.remove(cls);
            });
            element.classList.add(this.selectedElement.backgroundAttachment);
            this.dispatchUpdatePage();
        }
    },
    applyBackgroundPosition() {
        const element = document.getElementById(this.selectedElement.id);
        if (element) {
            ['bg-bottom', 'bg-center', 'bg-left', 'bg-left-bottom', 'bg-left-top', 'bg-right', 'bg-right-bottom', 'bg-right-top', 'bg-top'].forEach(cls => {
                element.classList.remove(cls);
            });
            element.classList.add(this.selectedElement.elementBackgroundPosition);
            this.dispatchUpdatePage();
        }
    },
    /**
     * Применяет ширину секции.
     * @param {string} width - Класс Tailwind для ширины.
     */
    applySectionWidth(width) {
        console.log('applySectionWidth', width);
        const element = document.getElementById(this.selectedElement.id);
        if (element) {
            element.classList.remove('w-full', 'container', 'space-x-2');
            element.classList.add(width);
            this.dispatchUpdatePage();
        }
    },
    applyShadow() {
        const element = document.getElementById(this.selectedElement.id);
        if (element) {
            ['shadow-none', 'shadow-sm', 'shadow', 'shadow-md', 'shadow-lg', 'shadow-xl', 'shadow-2xl'].forEach(cls => {
                element.classList.remove(cls);
            });
            element.classList.add(this.selectedElement.shadow);
            this.dispatchUpdatePage();
        }
    },
    applyRounded() {
        const element = document.getElementById(this.selectedElement.id);
        if (element) {
            ['rounded-none', 'rounded-sm', 'rounded', 'rounded-md', 'rounded-lg', 'rounded-xl', 'rounded-2xl', 'rounded-full'].forEach(cls => {
                element.classList.remove(cls);
            });
            element.classList.add(this.selectedElement.rounded);
            this.dispatchUpdatePage();
        }
    },
    applyAnimation() {
        const element = document.getElementById(this.selectedElement.id);
        if (element) {
            ['animate-spin', 'animate-ping', 'animate-pulse', 'animate-bounce', 'animate-fade', 'animate-slide'].forEach(cls => {
                element.classList.remove(cls);
            });
            if (this.selectedElement.animation) {
                element.classList.add(this.selectedElement.animation);
            }
            this.dispatchUpdatePage();
        }
    },
    applyTransition() {
        const element = document.getElementById(this.selectedElement.id);
        if (element) {
            ['transition-none', 'transition-all', 'transition-opacity', 'transition-transform'].forEach(cls => {
                element.classList.remove(cls);
            });
            if (this.selectedElement.transition) {
                element.classList.add(this.selectedElement.transition);
            }
            this.dispatchUpdatePage();
        }
    },
    applyTransform() {
        const element = document.getElementById(this.selectedElement.id);
        if (element) {
            ['transform-none', 'transform', 'rotate-45', 'scale-110', 'translate-x-4', 'translate-y-4'].forEach(cls => {
                element.classList.remove(cls);
            });
            if (this.selectedElement.transform) {
                element.classList.add(...this.selectedElement.transform.split(' '));
            }
            this.dispatchUpdatePage();
        }
    },

        // Новые методы
        toggleLightbox() {
            const element = document.getElementById(this.selectedElement.id);
            if (element) {
                if (this.selectedElement.lightboxEnabled) {
                    // Оборачиваем элемент в ссылку
                    const wrapper = document.createElement('a');
                    wrapper.setAttribute('href', this.selectedElement.lightboxImageUrl || element.getAttribute('src'));
                    wrapper.setAttribute('data-lightbox', 'image');
                    element.parentNode.insertBefore(wrapper, element);
                    wrapper.appendChild(element);
                } else {
                    // Разворачиваем элемент из ссылки
                    const parent = element.parentElement;
                    if (parent && parent.tagName === 'A' && parent.hasAttribute('data-lightbox')) {
                        parent.parentNode.insertBefore(element, parent);
                        parent.remove();
                    }
                }
                this.dispatchUpdatePage();
            }
        },
        updateLightboxImageUrl() {
            const element = document.getElementById(this.selectedElement.id);
            if (element) {
                const parent = element.parentElement;
                if (parent && parent.tagName === 'A' && parent.hasAttribute('data-lightbox')) {
                    parent.setAttribute('href', this.selectedElement.lightboxImageUrl || element.getAttribute('src'));
                    this.dispatchUpdatePage();
                }
            }
        },
        handleLightboxImageUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const formData = new FormData();
                formData.append('image', file);
    
                axios.post('/admin/upload-image', formData, {
                    headers: {
                        'Content-Type': 'multipart/form-data'
                    }
                })
                .then(response => {
                    this.selectedElement.lightboxImageUrl = response.data.url;
                    this.updateLightboxImageUrl();
                })
                .catch(error => {
                    console.error('Ошибка загрузки изображения:', error);
                });
            }
        },
});

// resources/js/components/element-component.js
export default () => ({
    init() {
        console.log('init element component');
    },
});

// resources/js/components/editor.js
import { v4 as uuidv4 } from 'uuid';
import axios from 'axios';
import common from './common';

export default () => ({
    ...common(), // Включаем общие методы
    isDragging: false,
    pageId: null,
    pageContent: '',
    highlightedElement: null,
    deviceMode: 'desktop', // По умолчанию режим десктопа
    selectedTemplate: null,
    get selectedElement() {
        return Alpine.store('editorStore').selectedElement;
    },
    set selectedElement(val) {
        Alpine.store('editorStore').selectedElement = val;
    },
    get showModal() {
        return Alpine.store('editorStore').showModal;
    },
    set showModal(val){
        Alpine.store('editorStore').showModal = val;
    },
    get modalCode() {
        return Alpine.store('editorStore').modalCode;
    },
    set modalCode(val){
        Alpine.store('editorStore').modalCode = val;
    },

    get showPanel() {
        return Alpine.store('editorStore').showPanel;
    },
    set showPanel(val) {
        Alpine.store('editorStore').showPanel = val;
    },
    init() {
        this.pageId = document.querySelector('main').getAttribute('data-page-id');
        this.pageContent = JSON.parse(document.querySelector('main').getAttribute('data-page-content'));
        //console.log('init editor component', this.pageId, this.pageContent);
          this.$watch('selectedElement', (newVal) => {
            console.log('selectedElement updated:', newVal); // Debug log for watching changes
          });

        if (!window.cloneElementRegistered) {
            window.cloneElementRegistered = true;
            // ==== ЛЕВЫЙ КЛИК ====
            document.querySelector('main').addEventListener('click', (event) => {
                    // Клик внутри панели редактирования или модального окна не должен затирать выбранный элемент.
                if (event.target.closest('[x-data="elementEditor"]') || event.target.closest('[x-show="showModal"]')) {
                    console.log('Click inside modal or editor panel'); // для отладки
                    event.stopPropagation();
                    return;
                }
                // Срабатывает только при левом клике
                if (event.button === 0) {
                    // 1. Проверяем, кликнули ли мы в панель (которая у вас находится справа)
                    const panelEl = document.querySelector('.panel-right'); 
                    const panelLeft = document.querySelector('.leftPanel'); 
                    const modal = document.querySelector('.modal');
                    // или используйте более надёжный селектор / id
            
                    if (panelEl && panelEl.contains(event.target)) {
                        // Клик внутри панели -> ничего не делаем, 
                        // чтобы панель не закрывалась
                        return;
                    }
                    if (panelLeft && panelLeft.contains(event.target)) {
                        // Клик внутри панели -> ничего не делаем, 
                        // чтобы панель не закрывалась
                        return;
                    }
                    if (modal && modal.contains(event.target)) {
                        // Клик внутри панели -> ничего не делаем, 
                        // чтобы панель не закрывалась
                        return;
                    }
                    
                    event.preventDefault();
                    // 2. Если клик не в панели, проверяем, есть ли data-id
                    let target = event.target.closest('[data-id]');
                    if (target) {
                        this.selectElement(target);
                    } else {
                        this.clearSelection();
                    }
            
                    this.hideContextMenu();
                }
            });

            // ==== ПРАВЫЙ КЛИК ====
            document.addEventListener('contextmenu', (event) => {
                let target = event.target.closest('[data-id]');
                if (target) {
                    event.preventDefault();
                    this.selectElement(target);
                    this.showContextMenu(event, target);
                } else {
                    this.clearSelection();
                    this.hideContextMenu();
                }
            });

        // Обработчики событий для клонирования, удаления и редактирования элементов



            document.addEventListener('clone-element', (event) => {
                this.cloneElement(event.detail.id);
            });
            document.addEventListener('remove-element', (event) => {
                this.removeElement(event.detail.id);
            });
            document.addEventListener('edit-code', (event) => {
                this.editCode(event.detail.id);
            });
            document.addEventListener('save-page', () => {
                this.savePage();
            });
            document.addEventListener('move-up', (event) => {
                this.moveUp(event.detail.id);
            });
            document.addEventListener('move-down', (event) => {
                this.moveDown(event.detail.id);
            });

            document.addEventListener('select-parent', (event) => {
                this.selectParentElement(event.detail.id);
            });
        }


    },
    base64ToUnicode(str) {
        const binaryString = window.atob(str);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        const decoder = new TextDecoder('utf-8');
        return decoder.decode(bytes);
    },
    
    selectParentElement(elementId) {
        console.log('selectParentElement');
        let element = document.querySelector(`[data-id="${elementId}"]`);
        if (element) {
            let parentElement = element.parentElement;
            while (parentElement && !parentElement.getAttribute('data-id')) {
                parentElement = parentElement.parentElement;
            }
            if (parentElement && parentElement.getAttribute('data-id')) {
                this.selectElement(parentElement);
            } else {
                alert('Родительский элемент не найден.');
            }
        } else {
            alert('Элемент не найден.');
        }
        this.hideContextMenu();
    },
   /**
     * Выбирает элемент для редактирования.
     * @param {HTMLElement} target - DOM-элемент, который был выбран.
     */
   selectElement(target) {
    console.log('selectElement', target);

    if (target && ['BUTTON', 'A', 'P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'SPAN','LI','UL','OL','DD','DT'].includes(target.tagName)) {
        console.log('p');
        this.showPanel = true;

        const TEXT_TAGS = ['P', 'SPAN', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6','A','LI','DD','DT'];

        let elementId = target.getAttribute('data-id');
        let type = target.getAttribute('data-type');
        let cssClasses = (target.getAttribute('class') || '').split(' ').filter(c => c !== 'hover-highlight').join(' ');
        let id = target.getAttribute('id') || '';

        let isText = false;
        let isImage = false;

        let textEl = null;
        console.log('Element ID:', elementId);  // Debug log for Element ID
        if (TEXT_TAGS.includes(target.tagName)) {
            // Если сам target – это p, span, h1 и т.д.
            textEl = target;
            isText = true;
        } else {
            // Иначе ищем внутри
            textEl = target.querySelector('p, span, h1, h2, h3, h4, h5, h6','a','li','ul','ol');
        }


        let text = isText ? textEl.textContent.trim() : '';
        let imageUrl = isImage ? textEl.getAttribute('src') : '';
        let textSize = isText ? textEl.style.fontSize : 16;
        let textColor = isText ? textEl.style.color : '#000000';
        let isBold = isText ? textEl.style.fontWeight === 'bold' : false;
        let isItalic = isText ? textEl.style.fontStyle === 'italic' : false;

        // Новые свойства
        let shadow = ['shadow-none', 'shadow-sm', 'shadow', 'shadow-md', 'shadow-lg', 'shadow-xl', 'shadow-2xl'].find(cls => target.classList.contains(cls)) || '';
        let rounded = ['rounded-none', 'rounded-sm', 'rounded', 'rounded-md', 'rounded-lg', 'rounded-xl', 'rounded-2xl', 'rounded-full'].find(cls => target.classList.contains(cls)) || '';
        let animation = ['animate-spin', 'animate-ping', 'animate-pulse', 'animate-bounce', 'animate-fade', 'animate-slide'].find(cls => target.classList.contains(cls)) || '';
        let transition = ['transition-none', 'transition-all', 'transition-opacity', 'transition-transform'].find(cls => target.classList.contains(cls)) || '';
        let transform = ['transform-none', 'transform', 'rotate-45', 'scale-110', 'translate-x-4', 'translate-y-4'].find(cls => target.classList.contains(cls)) || '';

        // Свойства для текста
        let textClass = ['text-xs', 'text-sm', 'text-base', 'text-lg', 'text-xl', 'text-2xl', 'text-3xl', 'text-4xl', 'text-5xl', 'text-6xl', 'text-7xl', 'text-8xl', 'text-9xl'].find(cls => target.classList.contains(cls)) || '';
        let textFont = ['font-thin', 'font-extralight', 'font-light', 'font-normal', 'font-medium', 'font-semibold', 'font-bold', 'font-extrabold', 'font-black'].find(cls => target.classList.contains(cls)) || '';


        Alpine.store('editorStore').selectedElement = {
            type: type,
            id: id,
            tag: target.tagName,
            cssClasses: cssClasses,
            text: text,
            imageUrl: imageUrl,
            isText: !!isText,
            isImage: !!isImage,
            elementId: elementId,
            textColor: textColor,
            textSize: textSize,
            isBold: isBold,
            isItalic: isItalic,

            blockCssClasses: type === 'block' ? cssClasses : '',
            blockId: type === 'block' ? id : '',
            elementCssClasses: type === 'element' ? cssClasses : '',
            elementText: type === 'element' && isText ? text : '',
            elementImageUrl: type === 'element' && isImage ? imageUrl : '',
            elementTextColor: type === 'element' && isText ? textColor : '#000000',
            elementTextSize: type === 'element' && isText ? textSize : 16,
            parallaxStrength: type === 'block' ? target.getAttribute('data-parallax-strength') || 5 : 5, // Добавляем силу параллакса
            href: ['A'].includes(target.tagName) ? textEl.getAttribute('href') : '',

            // Новые свойства
            shadow: shadow,
            rounded: rounded,
            animation: animation,
            transition: transition,
            transform: transform,

            // Свойства для текста
            textClass: textClass,
            textFont: textFont,
        };

        //this.elementId = type === 'element' ? id : '';

    }

    if (target && ['IMG'].includes(target.tagName)) {
        console.log('img');
        this.showPanel = true;
        let elementId = target.getAttribute('data-id');
        let type = target.getAttribute('data-type');
        let cssClasses = (target.getAttribute('class') || '').split(' ').filter(c => c !== 'hover-highlight').join(' ');
        let id = target.getAttribute('id') || '';
        let isText = false;
        let isImage = true;
        let imgEl = target;
        const parent = target.parentElement;

        let text = isText ? imgEl.textContent : '';
        let imageUrl = isImage ? imgEl.getAttribute('src') : '';
        let textSize = isText ? imgEl.style.fontSize : 16;
        let textColor = isText ? imgEl.style.color : '#000000';
        let isBold = isText ? imgEl.style.fontWeight === 'bold' : false;
        let isItalic = isText ? imgEl.style.fontStyle === 'italic' : false;

        // Новые свойства
        let shadow = ['shadow-none', 'shadow-sm', 'shadow', 'shadow-md', 'shadow-lg', 'shadow-xl', 'shadow-2xl'].find(cls => target.classList.contains(cls)) || '';
        let rounded = ['rounded-none', 'rounded-sm', 'rounded', 'rounded-md', 'rounded-lg', 'rounded-xl', 'rounded-2xl', 'rounded-full'].find(cls => target.classList.contains(cls)) || '';
        let animation = ['animate-spin', 'animate-ping', 'animate-pulse', 'animate-bounce', 'animate-fade', 'animate-slide'].find(cls => target.classList.contains(cls)) || '';
        let transition = ['transition-none', 'transition-all', 'transition-opacity', 'transition-transform'].find(cls => target.classList.contains(cls)) || '';
        let transform = ['transform-none', 'transform', 'rotate-45', 'scale-110', 'translate-x-4', 'translate-y-4'].find(cls => target.classList.contains(cls)) || '';

        // Свойства для фона
        let backgroundRepeat = ['bg-repeat', 'bg-no-repeat', 'bg-repeat-x', 'bg-repeat-y', 'bg-repeat-round', 'bg-repeat-space'].find(cls => target.classList.contains(cls)) || '';
        let backgroundSize = ['bg-auto', 'bg-cover', 'bg-contain'].find(cls => target.classList.contains(cls)) || '';
        let backgroundAttachment = ['bg-fixed', 'bg-local', 'bg-scroll'].find(cls => target.classList.contains(cls)) || '';
        let elementBackgroundPosition = ['bg-bottom', 'bg-center', 'bg-left', 'bg-left-bottom', 'bg-left-top', 'bg-right', 'bg-right-bottom', 'bg-right-top', 'bg-top'].find(cls => target.classList.contains(cls)) || '';

        let lightboxEnabled = parent && parent.tagName === 'A' && parent.hasAttribute('data-lightbox');
        let elementBackgroundSize = ['bg-auto', 'bg-cover', 'bg-contain'].find(cls => target.classList.contains(cls)) || '';


        Alpine.store('editorStore').selectedElement = {
            type: type,
            id: id,
            tag: target.tagName,
            cssClasses: cssClasses,
            text: text,
            imageUrl: imageUrl,
            isText: !!isText,
            isImage: !!isImage,
            elementId: elementId,
            textColor: textColor,
            textSize: textSize,
            isBold: isBold,
            isItalic: isItalic,
            blockCssClasses: type === 'block' ? cssClasses : '',
            blockId: type === 'block' ? id : '',
            elementCssClasses: type === 'element' ? cssClasses : '',
            elementText: type === 'element' && isText ? text : '',
            elementImageUrl: type === 'element' && isImage ? imageUrl : '',
            elementTextColor: type === 'element' && isText ? textColor : '#000000',
            elementTextSize: type === 'element' && isText ? textSize : 16,
            parallaxStrength: type === 'block' ? target.getAttribute('data-parallax-strength') || 5 : 5, // Добавляем силу параллакса
            //elementBackgroundSize: elementBackgroundSize,
            // Новые свойства
            shadow: shadow,
            rounded: rounded,
            animation: animation,
            transition: transition,
            transform: transform,

            // Свойства для фона
            backgroundRepeat: backgroundRepeat,
            backgroundSize: backgroundSize,
            backgroundAttachment: backgroundAttachment,
            elementBackgroundPosition: elementBackgroundPosition,

            lightboxEnabled: lightboxEnabled,
            lightboxImageUrl: lightboxEnabled ? parent.getAttribute('href') : "",

        };

    }

    if (target && ['DIV', 'SECTION', 'FOOTER', 'HEADER'].includes(target.tagName)) {

        console.log(this.showPanel);
        this.showPanel = true;
        console.log('DIV');
        console.log(this.showPanel);
        console.log(Alpine.store('editorStore').selectedElement);
        let elementId = target.getAttribute('data-id');
        let type = target.getAttribute('data-type');
        let cssClasses = (target.getAttribute('class') || '').split(' ').filter(c => c !== 'hover-highlight').join(' ');
        let id = target.getAttribute('id') || '';
        let isText = target.querySelector('p, span, h1, h2, h3, h4, h5, h6');
        let isImage = target.querySelector('img');
        let text = isText ? isText.textContent : '';
        let imageUrl = isImage ? isImage.getAttribute('src') : '';
        let textSize = isText ? isText.style.fontSize : 16;
        let textColor = isText ? isText.style.color : '#000000';
        let isBold = isText ? isText.style.fontWeight === 'bold' : false;
        let isItalic = isText ? isText.style.fontStyle === 'italic' : false;
        let backgroundImage = target.style.backgroundImage ? target.style.backgroundImage.slice(5, -2) : '';
        let backgroundColor = target.style.backgroundColor ? target.style.backgroundColor : '';
        //let elementBackgroundSize = ['bg-auto', 'bg-cover', 'bg-contain'].find(cls => target.classList.contains(cls)) || '';
        let parallax = target.style.backgroundAttachment === 'fixed';

        // Новые свойства
        let shadow = ['shadow-none', 'shadow-sm', 'shadow', 'shadow-md', 'shadow-lg', 'shadow-xl', 'shadow-2xl'].find(cls => target.classList.contains(cls)) || '';
        let rounded = ['rounded-none', 'rounded-sm', 'rounded', 'rounded-md', 'rounded-lg', 'rounded-xl', 'rounded-2xl', 'rounded-full'].find(cls => target.classList.contains(cls)) || '';
        let animation = ['animate-spin', 'animate-ping', 'animate-pulse', 'animate-bounce', 'animate-fade', 'animate-slide'].find(cls => target.classList.contains(cls)) || '';
        let transition = ['transition-none', 'transition-all', 'transition-opacity', 'transition-transform'].find(cls => target.classList.contains(cls)) || '';
        let transform = ['transform-none', 'transform', 'rotate-45', 'scale-110', 'translate-x-4', 'translate-y-4'].find(cls => target.classList.contains(cls)) || '';


        // Свойства для фона
        let backgroundRepeat = ['bg-repeat', 'bg-no-repeat', 'bg-repeat-x', 'bg-repeat-y', 'bg-repeat-round', 'bg-repeat-space'].find(cls => target.classList.contains(cls)) || '';
        let backgroundSize = ['bg-auto', 'bg-cover', 'bg-contain'].find(cls => target.classList.contains(cls)) || '';
        let backgroundAttachment = ['bg-fixed', 'bg-local', 'bg-scroll'].find(cls => target.classList.contains(cls)) || '';
        let elementBackgroundPosition = ['bg-bottom', 'bg-center', 'bg-left', 'bg-left-bottom', 'bg-left-top', 'bg-right', 'bg-right-bottom', 'bg-right-top', 'bg-top'].find(cls => target.classList.contains(cls)) || '';


        // Свойства для текста
        let textClass = ['text-xs', 'text-sm', 'text-base', 'text-lg', 'text-xl', 'text-2xl', 'text-3xl', 'text-4xl', 'text-5xl', 'text-6xl', 'text-7xl', 'text-8xl', 'text-9xl'].find(cls => target.classList.contains(cls)) || '';
        let textFont = ['font-thin', 'font-extralight', 'font-light', 'font-normal', 'font-medium', 'font-semibold', 'font-bold', 'font-extrabold', 'font-black'].find(cls => target.classList.contains(cls)) || '';

        Alpine.store('editorStore').selectedElement = {
            type: type,
            id: id,
            tag: target.tagName,
            //blockCssClasses: '',
            //blockId: '',
            //elementCssClasses: '',
            elementId: elementId,
            //elementText: '',
            //elementImageUrl: '',
            elementBackgroundColor: backgroundColor || '#ffffff',
            elementBackgroundUrl: backgroundImage,
            elementBackgroundPosition: elementBackgroundPosition,
            //elementTextColor: '#000000',
            //elementTextSize: 16,
            elementParallax: parallax,

            blockCssClasses: type === 'block' ? cssClasses : '',
            blockId: type === 'block' ? id : '',
            elementCssClasses: type === 'element' ? cssClasses : '',
            elementText: type === 'element' && isText ? text : '',
            elementImageUrl: type === 'element' && isImage ? imageUrl : '',
            elementTextColor: type === 'element' && isText ? textColor : '#000000',
            elementTextSize: type === 'element' && isText ? textSize : 16,
            parallaxStrength: type === 'block' ? target.getAttribute('data-parallax-strength') || 5 : 5, // Добавляем силу параллакса
            //elementBackgroundSize: elementBackgroundSize,
            // Новые свойства
            shadow: shadow,
            rounded: rounded,
            animation: animation,
            transition: transition,
            transform: transform,

            // Свойства для фона
            backgroundRepeat: backgroundRepeat,
            backgroundSize: backgroundSize,
            backgroundAttachment: backgroundAttachment,

            // Свойства для текста
            textClass: textClass,
            textFont: textFont,
        };

        
    }

    console.log('Final selectedElement:', Alpine.store('editorStore').selectedElement);
}, 
setDeviceMode(mode) {
    this.deviceMode = mode;
    this.applyDeviceMode();
},

applyDeviceMode() {
    const editor = document.querySelector('.editor');
    if (editor) {
        editor.classList.remove('desktop-mode', 'tablet-mode', 'mobile-mode');
        editor.classList.add(`${this.deviceMode}-mode`);
    }
},
saveTemplate() {
    const templateName = prompt('Введите название шаблона:');
    if (templateName) {
        axios.post('/templates', {
            name: templateName,
            content: this.pageContent,
        }).then(response => {
            alert('Шаблон успешно сохранен!');
        }).catch(error => {
            console.error('Ошибка сохранения шаблона:', error);
        });
    }
},
applyTemplate() {
    if (this.selectedTemplate) {
        axios.get(`/templates/${this.selectedTemplate}`).then(response => {
            this.pageContent = response.data.content;
            this.$nextTick(() => {
                this.updateElementContent();
            });
        }).catch(error => {
            console.error('Ошибка загрузки шаблона:', error);
        });
    }
},
    cloneElement(elementId) {
            console.log('cloneElement', elementId)
        this.hideContextMenu();
        let element = document.querySelector(`[data-id="${elementId}"]`);
        if (element) {
            let clonedElement = element.cloneNode(true);
            let newElementId =  Math.random().toString(36).substring(2, 15);
            clonedElement.setAttribute('data-id', newElementId)
            if(clonedElement.id){
                clonedElement.id = 'element-' + newElementId
            }
            clonedElement.querySelectorAll('[data-id]').forEach(el => {
                let newId =  Math.random().toString(36).substring(2, 15);
                el.setAttribute('data-id', newId);
                if(el.id){
                    el.id = 'element-' + newId;
                }
            });
            element.parentNode.insertBefore(clonedElement, element.nextSibling);
        }
        this.$nextTick(() => {
            this.updateElement();
        })
    },
    removeElement(elementId) {
        console.log('removeElement', elementId)
        this.hideContextMenu();
        let element = document.querySelector(`[data-id="${elementId}"]`);
        if (element) {
            element.remove();
        }
        this.$nextTick(() => {
            this.updateElement();
        })
    },
    updateElement() {
        console.log('updateElement')
       this.pageContent = document.getElementById('page-content').innerHTML;
   },
        // Показываем контекстное меню (для правого клика)
        showContextMenu(event, target) {
            event.preventDefault();
            this.hideContextMenu(); // Сначала убираем предыдущее меню
    
            const menu = document.createElement('div');
            menu.classList.add('context-menu');
            // Задаём координаты там, где был клик
            menu.style.left = event.clientX + 'px';
            menu.style.top = event.clientY + 'px';
    
            const dataId = target.getAttribute('data-id');
            menu.innerHTML = `
                <button class="context-menu-item"
                        @click.stop="$dispatch('clone-element', { id: '${dataId}' })">
                    Клонировать
                </button>
                <button class="context-menu-item"
                        @click.stop="$dispatch('remove-element', { id: '${dataId}' })">
                    Удалить
                </button>
                <button class="context-menu-item"
                @click.stop="$dispatch('move-up', { id: '${dataId}' })">
                    Переместить вверх
                </button>
                <button class="context-menu-item"
                        @click.stop="$dispatch('move-down', { id: '${dataId}' })">
                    Переместить вниз
                </button>
                <button class="context-menu-item"
                        @click.stop="$dispatch('edit-code', { id: '${dataId}' })">
                    Редактировать код
                </button>
                    <button class="context-menu-item"
                        @click.stop="$dispatch('select-parent', { id: '${dataId}' })">
                    Выбрать родителя
                </button>
            `;
    
            // Добавляем во всю страницу
            document.body.appendChild(menu);
    
            // Закрыть меню при клике вне его
            document.addEventListener('click', (evt) => {
                if (menu && !menu.contains(evt.target)) {
                    this.hideContextMenu();
                }
            }, { once: true });
        },
        moveUp(elementId) {
            const element = document.querySelector(`[data-id="${elementId}"]`);
            if (element && element.previousElementSibling) {
                element.parentNode.insertBefore(element, element.previousElementSibling);
                this.$nextTick(() => {
                    this.updateElementContent();
                });
            }
        },
        moveDown(elementId) {
            const element = document.querySelector(`[data-id="${elementId}"]`);
            if (element && element.nextElementSibling) {
                element.parentNode.insertBefore(element.nextElementSibling, element);
                this.$nextTick(() => {
                    this.updateElementContent();
                });
            }
        },    
    editCode(elementId) {
        let element = document.querySelector(`[data-id="${elementId}"]`);
        console.log('editCode, Element ID:', elementId);  // Debug log for Element ID
        if (element) {
            Alpine.store('editorStore').modalCode = element.outerHTML;
            Alpine.store('editorStore').showModal = true;
            console.log('Element HTML:', element.outerHTML);  // Debug log for Element HTML
        } else {
            console.log('Element not found with data-id:', elementId);  // Error log if element not found
        }
      },
      highlightElement(event) {
        let target = event.target;
        // Ищем ближайший родительский элемент с data-id
        while (target && !target.getAttribute('data-id')) {
            target = target.parentElement;
        }
        if (target) {
            this.removeHighlight();
            target.classList.add('hover-highlight');
            this.highlightedElement = target;
        }
    },
    removeHighlight() {
        if (this.highlightedElement) {
            this.highlightedElement.classList.remove('hover-highlight');
            this.highlightedElement = null;
        }
    },
    handleDrop(event) {
        console.log('handleDrop');
        this.isDragging = false;
        const typeAndId = event.dataTransfer.getData('text/plain');
        const [type, id] = typeAndId.split('-');
        if (type === 'block') {
            this.addBlockToPage(id, event.target);
        } else if (type === 'element') {
            if(event.target.classList.contains('page-content')){
                this.addElementToPage(id, event.target);
            } else {
                this.handleElementDrop(event, id);
            }

        }
    },

    handleElementDrop(event, elementId){
        console.log('handleElementDrop');
        event.preventDefault();
        let target = event.target;
        while (target && !target.getAttribute('data-id')) {
            target = target.parentElement;
        }
        if (target) {
            this.addBlockToPage(elementId, target);
        }
    },

    addBlockToPage(blockId, target) {
        console.log('addBlockToPage', blockId);
        axios.get(`/getblocks/${blockId}`).then(response => {
            const blockHTML = response.data.html_code;
            let newBlockId = uuidv4();
            const tempElement = document.createElement('div');
            tempElement.innerHTML = blockHTML;
            const firstChild = tempElement.firstElementChild;
            const blockType = response.data.type;
            if (firstChild) {
                firstChild.setAttribute('data-id', newBlockId);
                firstChild.setAttribute('data-type', blockType);
                if(!firstChild.getAttribute('id')){
                    firstChild.setAttribute('id', blockType + '-' + newBlockId);
                }
                if(response.data.preview){
                    let img = firstChild.querySelector('img');
                    if(img){
                        img.setAttribute('src', response.data.preview);
                    }
                }

                if (blockType === 'element') {
                    // Проверяем, можно ли вставить элемент внутрь целевого элемента
                    const forbiddenTags = ['IMG', 'INPUT', 'BR', 'HR', 'META', 'LINK'];
                    if (target && !forbiddenTags.includes(target.tagName)) {
                        // Вставляем элемент внутрь целевого элемента
                        target.appendChild(firstChild);
                    } else if (target.parentNode && !forbiddenTags.includes(target.parentNode.tagName)) {
                        // Вставляем элемент внутрь родительского элемента
                        target.parentNode.appendChild(firstChild);
                    } else {
                        // Если не удалось найти подходящий элемент, вставляем в конец страницы
                        document.getElementById('page-content').appendChild(firstChild);
                    }
                } else {
                    // Логика для блоков
                    this.pageContent = this.pageContent ? this.pageContent + tempElement.innerHTML : tempElement.innerHTML;
                }

                
                // Вставляем блок перед целевым элементом
                //target.insertAdjacentHTML('beforebegin', tempElement.innerHTML);
                this.$nextTick(() => {
                    this.updateElementContent();
                });
            }
        }).catch(error => {
            console.error('Error fetching block:', error);
            alert('Ошибка загрузки блока: ' + error.message);
        });
    },
    /*
    addElementToPage22(elementId, target) {
        console.log('addElementToPage', elementId, target);
        axios.get(`/getblocks/${elementId}`).then(response => {
            const elementHTML = response.data.html_code;
            let newElementId = uuidv4();
            const tempElement = document.createElement('div');
            const blockType = response.data.type;
            tempElement.innerHTML = elementHTML;
            const firstChild = tempElement.firstElementChild;
            if (firstChild) {
                firstChild.setAttribute('data-id', newElementId);
                firstChild.setAttribute('data-type', blockType);
                if(!firstChild.getAttribute('id')){
                    firstChild.setAttribute('id', blockType +'-' + newElementId);
                }
                if(response.data.preview){
                    let img = firstChild.querySelector('img');
                    if(img){
                        img.setAttribute('src', response.data.preview);
                    }
                }
                //target.insertAdjacentHTML('beforeend', tempElement.innerHTML);




                this.$nextTick(() => {
                    this.updateElementContent();
                });
            }
        }).catch(error => {
            console.error('Error fetching element:', error);
            alert('Ошибка загрузки элемента: ' + error.message);
        });
    },
*/
    // Сохранение страницы через API
    savePage() {
        console.log('savePage');
        axios.put(`/page-builds/${this.pageId}`, {
            content: this.pageContent,
        })
        .then(response => {
            //this.pageContent = response.data.content;
            //this.$nextTick(() => {
            //    this.updateElementContent();
            //});
            alert(response.data.message);
        })
        .catch(error => {
            console.error('Ошибка сохранения страницы:', error);
            alert('Ошибка сохранения страницы: ' + error.message);
        });
    },

    // Экспорт страницы
    exportPage() {
        console.log('exportPage');
        axios.get(`/page-builds/${this.pageId}/export`)
            .then(response => {
                const blob = new Blob([response.data], { type: 'text/html' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${this.pageId}.zip`;
                a.click();
                window.URL.revokeObjectURL(url);
            })
            .catch(error => {
                console.error('Ошибка экспорта страницы:', error);
                alert('Ошибка экспорта страницы: ' + error.message);
            });
    },

    // Предпросмотр страницы
    previewPage() {
        console.log('previewPage');
        window.open(`/pages/${this.pageId}/preview`, '_blank');
    }
});

// resources/js/components/common.js
export default () => ({

    get selectedElement() {
        return Alpine.store('editorStore').selectedElement;
    },
    set selectedElement(val) {
        Alpine.store('editorStore').selectedElement = val;
    },
    get showModal() {
        return Alpine.store('editorStore').showModal;
    },
    set showModal(val){
        Alpine.store('editorStore').showModal = val;
    },
    get modalCode() {
        return Alpine.store('editorStore').modalCode;
    },
    set modalCode(val){
        Alpine.store('editorStore').modalCode = val;
    },

    get showPanel() {
        return Alpine.store('editorStore').showPanel;
    },
    set showPanel(val) {
        Alpine.store('editorStore').showPanel = val;
    },

    /**
     * Применяет CSS-стиль к выбранному элементу.
     * @param {string} property - Название CSS-свойства.
     * @param {string} value - Значение CSS-свойства.
     */
    applyStyle(property, value) {
        console.log('applyStyle', property, value);
        const element = document.getElementById(this.selectedElement.id);
        if (element) {
            if (this.selectedElement.isText) {
                element.setAttribute(property, value);
            } else if (this.selectedElement.isImage) {
                let img = element.tagName === 'IMG' 
                    ? element 
                    : element.querySelector('img');
    
                if (img) {
                    img.setAttribute(property, value);
                }
            }
            this.dispatchUpdatePage();
        }
    },

    /**
     * Применяет текстовый стиль к выбранному элементу.
     * @param {string} property - Название текстового CSS-свойства.
     * @param {string} value - Значение текстового CSS-свойства.
     */
    applyTextStyle(property, value) {
        console.log('applyTextStyle', property, value);
        const element = document.getElementById(this.selectedElement.id);
        if (element && this.selectedElement.isText) {
            element.style[property] = value;
            this.dispatchUpdatePage();
        }
    },

    /**
     * Применяет фон к выбранному элементу.
     * @param {string} property - Название CSS-свойства для фона.
     * @param {string} value - Значение CSS-свойства для фона.
     */
    applyBackgroundStyle(property, value) {
        console.log('applyBackgroundStyle', property, value);
        const element = document.getElementById(this.selectedElement.id);
        if (element) {
            element.style[property] = value;
            this.dispatchUpdatePage();
        }
    },
    /**
     * Обновляет классы выбранного элемента.
     */
    updateClasses() {
        console.log('updateClasses');
        const element = document.getElementById(this.selectedElement.id);
        if (element) {
            // Получаем текущий список классов без hover-highlight
            let classes = this.selectedElement.type === 'block' ? this.selectedElement.blockCssClasses : this.selectedElement.elementCssClasses;
            // Удаляем hover-highlight из классов
            classes = classes.split(' ').filter(c => c !== 'hover-highlight').join(' ');
            // Устанавливаем атрибут class без hover-highlight
            element.setAttribute('class', classes);
            this.dispatchUpdatePage();
        }
    },

    /**
     * Обновляет ID выбранного элемента.
     */
    updateId() {
        console.log('updateId');
        const element = document.getElementById(this.selectedElement.id);
        if (element) {
            element.setAttribute('id', this.selectedElement.type === 'block' ? this.blockId : this.elementId);
            this.dispatchUpdatePage();
        }
    },

    /**
     * Обновляет текст выбранного элемента.
     */
    updateText() {
        console.log('updateText');
        const element = document.getElementById(this.selectedElement.id);
        if (element && this.selectedElement.isText) {
            let textElement = element.querySelector('p, span, h1, h2, h3, h4, h5, h6');
            if (textElement) {
                textElement.textContent = this.selectedElement.elementText;
            }
            this.dispatchUpdatePage();
        }
    },
    updateText() {
        console.log('updateText');
        const element = document.getElementById(this.selectedElement.id);
        if (!element) return;
    
        element.textContent = this.selectedElement.elementText;
    
        this.dispatchUpdatePage();
    },
    /**
     * Обновляет цвет фона выбранного элемента.
     */
    updateBackgroundColor() {
        console.log('updateBackgroundColor');
        const element = document.getElementById(this.selectedElement.id);
        if (element) {
            element.style.backgroundColor = this.selectedElement.elementBackgroundColor;
            this.dispatchUpdatePage();
        }
    },

    /**
     * Обновляет цвет текста выбранного элемента.
     */
    updateTextColor() {
        console.log('updateTextColor');
        const element = document.getElementById(this.selectedElement.id);
        if (element && this.selectedElement.isText) {
            element.style.color = this.selectedElement.elementTextColor;
            this.dispatchUpdatePage();
        }
    },

    /**
     * Обновляет размер текста выбранного элемента.
     */
    updateTextSize() {
        console.log('updateTextSize');
        const element = document.getElementById(this.selectedElement.id);
        if (element && this.selectedElement.isText) {
            element.style.fontSize = `${this.selectedElement.elementTextSize}px`;
            this.dispatchUpdatePage();
        }
    },

    /**
     * Обновляет состояние страницы после изменения.
     */
    dispatchUpdatePage() {
        this.updateElementContent();
        // Можно добавить дополнительные действия, например, уведомления
    },

    /**
     * Обновляет содержимое страницы в состоянии Alpine.
     */
    updateElementContent() {
        this.pageContent = document.getElementById('page-content').innerHTML;
    },


hideContextMenu(){
    document.querySelectorAll('.context-menu').forEach(menu => {
        menu.remove()
    })
},
applyParallaxStyle() {
    console.log('applyParallaxStyle');
    const element = document.getElementById(this.selectedElement.id);
    if (element) {
        if (this.selectedElement.elementParallax) {
            // Применяем параллакс с учётом силы
            element.style.backgroundAttachment = 'fixed';
            element.style.backgroundPosition = 'center ' + (-this.selectedElement.parallaxStrength * 10) + 'px';
            element.setAttribute('data-parallax-strength', this.selectedElement.parallaxStrength);
        } else {
            // Отключаем параллакс
            element.style.backgroundAttachment = 'scroll';
            element.style.backgroundPosition = 'center center';
            element.removeAttribute('data-parallax-strength');
        }
        this.dispatchUpdatePage();
    }
},
colorTest() {
    console.log('colorTest called');
    console.log('New color = ', this.selectedElement.elementBackgroundColor);
},
clearSelection()
{
    Alpine.store('editorStore').selectedElement = {
        type: null,
        id: null,
        tag: null,
        cssClasses: null,
        text: null,
        imageUrl: null,
        isText: null,
        isImage: null,
        elementId: null,
        textColor: '#ffffff',
        elementBackgroundColor: '#ffffff',
        elementBackgroundSize: 'bg-cover',
        elementBackgroundPosition: 'bg-center',
        textSize: null,
        isBold: null,
        isItalic: null,
        blockCssClasses: null,
        blockId: null,
        elementCssClasses: null,
        elementText: null,
        elementImageUrl: null,
        elementTextColor: '#ffffff',
        elementTextSize: null,
        parallaxStrength: 5,
        href: null,
                // ... существующие свойства ...
                lightboxEnabled: false,
                lightboxImageUrl: '',
    };
    this.showPanel = false;
},

});

// resources/js/components/block-component.js
export default () => ({
    init() {
        console.log('init block component');
    },
});

// resources/views/partials/editor-element-panel.blade.php
<div class="flex justify-between items-center mb-4">
    <h3 class="text-lg font-bold">Редактирование элемента</h3>
    <button @click="clearSelection()" class="text-gray-500 hover:text-gray-700">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
            <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
        </svg>
    </button>
</div>
<div x-show="selectedElement && selectedElement.type === 'block'">
    <h4 class="text-md font-bold mb-2">Блок</h4>
    <div class="mb-2">
        <label class="block text-gray-700 text-sm font-bold mb-2" for="block-css-classes">CSS классы:</label>
        <input type="text" id="block-css-classes" x-model="selectedElement.blockCssClasses"  @input="updateClasses()" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
    </div>
    <div class="mb-2">
        <label class="block text-gray-700 text-sm font-bold mb-2" for="block-id">ID:</label>
        <input type="text" id="block-id" x-model="selectedElement.blockId" @input="updateId()" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
    </div>

    <div class="mb-2" x-show="selectedElement && ['DIV', 'SECTION','HEADER','FOOTER'].includes(selectedElement.tag?.toUpperCase())">
        <label class="block text-gray-700 text-sm font-bold mb-2">Параллакс:</label>
        <div class="flex items-center space-x-4">
            <input type="checkbox" x-model="selectedElement.elementParallax" @change="applyParallaxStyle()" >
            <label>Включить параллакс</label>
        </div>
        <!-- Добавляем ползунок для настройки силы параллакса -->
        <div class="mt-2" x-show="selectedElement.elementParallax">
            <label class="block text-gray-700 text-sm font-bold mb-2" for="parallax-strength">Сила параллакса:</label>
            <input type="range" id="parallax-strength" min="1" max="10" x-model.number="selectedElement.parallaxStrength" @input="applyParallaxStyle()" class="w-full">
            <span x-text="selectedElement.parallaxStrength"></span>
        </div>
    </div>

    <div class="mb-2" x-show="selectedElement && ['DIV', 'SECTION','HEADER','FOOTER'].includes(selectedElement.tag?.toUpperCase())">
        <label class="block text-gray-700 text-sm font-bold mb-2">Ширина:</label>
        <div class="flex space-x-2">
                <button @click="applySectionWidth('w-full')" class="px-2 py-1 rounded border">Полная ширина</button>
                <button @click="applySectionWidth('container')" class="px-2 py-1 rounded border">По контейнеру</button>
                <button @click="applySectionWidth('space-x-2')" class="px-2 py-1 rounded border">Space</button>
        </div>

        <label class="block text-gray-700 text-sm font-bold mb-2">Размер фона:</label>
        <select x-model="selectedElement.backgroundSize" @change="applyBackgroundSize()" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
            <option value="bg-auto">Авто</option>
            <option value="bg-cover">Покрыть</option>
            <option value="bg-contain">Вписать</option>
        </select>
    </div>
</div>
<div x-show="selectedElement && selectedElement.type === 'element'">
    <h4 class="text-md font-bold mb-2">Элемент</h4>
    <div class="mb-2">
        <label class="block text-gray-700 text-sm font-bold mb-2" for="element-css-classes">CSS классы:</label>
        <input type="text" id="element-css-classes" x-model="selectedElement.elementCssClasses" @input="updateClasses()" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
    </div>
    <div class="mb-2">
        <label class="block text-gray-700 text-sm font-bold mb-2" for="element-id">ID:</label>
        <input type="text" id="element-id" x-model="selectedElement.elementId" @input="updateId()" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
    </div>
    <div class="mb-2" x-show="selectedElement && selectedElement.isText">
        <label class="block text-gray-700 text-sm font-bold mb-2" for="element-text">Текст:</label>
        <textarea id="element-text" 
                  x-model="selectedElement.elementText"
                  @input="updateText()"
                  class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
        </textarea>
    </div>

    <div class="mb-2" x-show="selectedElement && selectedElement.isImage">
        <label class="block text-gray-700 text-sm font-bold mb-2">Изображение:</label>
        <div class="flex items-center space-x-4">
            <input type="text" id="element-image-url" x-model="selectedElement.elementImageUrl" placeholder="URL изображения" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
            <button @click="openMediaManager()" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded">
                Выбрать
            </button>
        </div>

    <!-- Новые опции для lightbox -->
    <h4 class="text-md font-bold mb-2 mt-4">Настройки Lightbox</h4>
        <div class="flex items-center mb-2">
            <input type="checkbox" id="lightbox-enabled" x-model="selectedElement.lightboxEnabled" @change="toggleLightbox()">
            <label for="lightbox-enabled" class="ml-2">Включить Lightbox</label>
        </div>
        <div x-show="selectedElement.lightboxEnabled">
            <div class="mb-2">
                <label class="block text-gray-700 text-sm font-bold mb-2" for="lightbox-image-url">URL изображения для Lightbox:</label>
                <input type="text" id="lightbox-image-url" x-model="selectedElement.lightboxImageUrl" @input="updateLightboxImageUrl()" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
            </div>
            <div class="flex items-center space-x-4">
                <!-- Заменяем input type="file" на кнопку -->
                <button @click="openMediaManagerForLightbox()" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded">
                    Выбрать изображение для Lightbox
                </button>
            </div>
        </div>
        
    </div>
    <div x-show="selectedElement && selectedElement.tag === 'A'">
        <h4 class="text-md font-bold mb-2">Ссылка</h4>
        <div class="mb-2">
            <label class="block text-gray-700 text-sm font-bold mb-2" for="link-href">Адрес (href):</label>
            <input type="text" id="link-href" x-model="selectedElement.href" @input="updateHref()" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
        </div>
        <div class="mb-2">
            <label class="block text-gray-700 text-sm font-bold mb-2" for="link-target">Цель (target):</label>
            <select id="link-target" x-model="selectedElement.target" @change="updateTarget()" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                <option value="_self">Открыть в текущем окне (_self)</option>
                <option value="_blank">Открыть в новом окне (_blank)</option>
                <option value="_parent">Открыть во фрейме (_parent)</option>
                <option value="_top">Открыть на всю страницу (_top)</option>
            </select>
        </div>
    </div>  
    <div x-show="selectedElement && ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'].includes(selectedElement.tag)">
        <h4 class="text-md font-bold mb-2">Заголовок</h4>
        <div class="mb-2">
            <label class="block text-gray-700 text-sm font-bold mb-2" for="header-type">Тип заголовка:</label>
            <select id="header-type" x-model="selectedElement.tag" @change="updateHeader()">
                <option value="H1">H1</option>
                <option value="H2">H2</option>
                <option value="H3">H3</option>
                <option value="H4">H4</option>
                <option value="H5">H5</option>
                <option value="H6">H6</option>
            </select>
        </div>
    </div>
    
    <!-- Простые стили -->
    <div x-show="selectedElement && selectedElement.type === 'element'">
        <h4 class="text-md font-bold mb-2">Стили</h4>
        <div class="mb-4" x-show="selectedElement && selectedElement.isText">
            <label class="block text-gray-700 text-sm font-bold mb-2">Стили:</label>
            <div class="flex space-x-2">
                <button @click="toggleStyle('bold')" 
                :class="{ 'bg-gray-200': selectedElement && selectedElement.isBold }"
                class="px-2 py-1 rounded border">B
                </button>
                <button @click="toggleStyle('italic')" 
                        :class="{ 'bg-gray-200': selectedElement && selectedElement.isItalic }"
                        class="px-2 py-1 rounded border">I
                </button>
                <input type="color" 
                    x-model="selectedElement.elementTextColor" 
                    @input="updateTextColor()">
                <input type="number"
                    x-model.number="selectedElement.elementTextSize"
                    @input="updateTextSize()"
                    placeholder="Размер"
                    class="shadow appearance-none border rounded w-16 py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
            </div>
        </div>
        <div class="mb-4" x-show="selectedElement && selectedElement.isText">
            <label class="block text-gray-700 text-sm font-bold mb-2">Стили текста:</label>
            <div class="flex flex-wrap space-x-2">
                <button @click="toggleStyle('underline')" :class="{ 'bg-gray-200': selectedElement.isUnderline }" class="px-2 py-1 rounded border">U</button>
                <button @click="toggleStyle('overline')" :class="{ 'bg-gray-200': selectedElement.isOverline }" class="px-2 py-1 rounded border">O</button>
                <button @click="toggleStyle('line-through')" :class="{ 'bg-gray-200': selectedElement.isLineThrough }" class="px-2 py-1 rounded border">S</button>
                <button @click="toggleStyle('no-underline')" :class="{ 'bg-gray-200': selectedElement.isNoUnderline }" class="px-2 py-1 rounded border">X</button>
            </div>
    
            <label class="block text-gray-700 text-sm font-bold mb-2">Размер текста:</label>
            <select x-model="selectedElement.textClass" @change="toggleTextClass()">
                <option value="text-xs">text-xs</option>
                <option value="text-sm">text-sm</option>
                <option value="text-base">text-base</option>
                <option value="text-lg">text-lg</option>
                <option value="text-xl">text-xl</option>
                <option value="text-2xl">text-2xl</option>
                <option value="text-3xl">text-3xl</option>
                <option value="text-4xl">text-4xl</option>
                <option value="text-5xl">text-5xl</option>
                <option value="text-6xl">text-6xl</option>
                <option value="text-7xl">text-7xl</option>
                <option value="text-8xl">text-8xl</option>
                <option value="text-9xl">text-9xl</option>
            </select>
    
            <label class="block text-gray-700 text-sm font-bold mb-2">Выравнивание текста:</label>
            <div class="flex flex-wrap space-x-2">
                <button @click="toggleAlignment('text-left')" class="px-2 py-1 rounded border">Left</button>
                <button @click="toggleAlignment('text-center')" class="px-2 py-1 rounded border">Center</button>
                <button @click="toggleAlignment('text-right')" class="px-2 py-1 rounded border">Right</button>
                <button @click="toggleAlignment('text-justify')" class="px-2 py-1 rounded border">Justify</button>
            </div>
    
            <label class="block text-gray-700 text-sm font-bold mb-2">Стиль текста:</label>
            <select x-model="selectedElement.textFont" @change="toggleTextFont()">
                <option value="font-thin">font-thin</option>
                <option value="font-extralight">font-extralight</option>
                <option value="font-light">font-light</option>
                <option value="font-normal">font-normal</option>
                <option value="font-medium">font-medium</option>
                <option value="font-semibold">font-semibold</option>
                <option value="font-bold">font-bold</option>
                <option value="font-extrabold">font-extrabold</option>
                <option value="font-black">font-black</option>
            </select>
        </div>

    </div>
</div>
<div class="mb-2" x-show="selectedElement && ['DIV', 'SECTION','HEADER','FOOTER'].includes(selectedElement.tag?.toUpperCase())">
    <label class="block text-gray-700 text-sm font-bold mb-2">Фон:</label>
    <div class="flex items-center space-x-4">
        <input type="text" id="element-background-url" x-model="selectedElement.elementBackgroundUrl" placeholder="URL изображения" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
        <input type="color" x-model="selectedElement.elementBackgroundColor" @input="updateBackgroundColor()" >
        <input type="file" id="element-background-file" @change="handleBackgroundChange($event)" class="hidden">
        <button @click="openMediaManagerForBackground()" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded">
            Выбрать
        </button>
        <!-- Кнопка для удаления фонового изображения -->
        <button @click="removeBackgroundImage()" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded">
            Убрать фон
        </button>
    </div>
</div>
<div class="mb-2" x-show="selectedElement && ['DIV', 'SECTION','HEADER','FOOTER'].includes(selectedElement.tag?.toUpperCase())">
    <label class="block text-gray-700 text-sm font-bold mb-2">Позиция фона:</label>
    <select x-model="selectedElement.elementBackgroundPosition" @change="applyBackgroundPosition()" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
        <option value="bg-bottom">bg-bottom</option>
        <option value="bg-center">bg-center</option>
        <option value="bg-left">bg-left</option>
        <option value="bg-left-bottom">bg-left-bottom</option>
        <option value="bg-left-top">bg-left-top</option>
        <option value="bg-right">bg-right</option>
        <option value="bg-right-bottom">bg-right-bottom</option>
        <option value="bg-right-top">bg-right-top</option>
        <option value="bg-top">bg-top</option>
    </select>
    <label class="block text-gray-700 text-sm font-bold mb-2">Размер фона:</label>
    <select x-model="selectedElement.backgroundSize" @change="applyBackgroundSize()" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
        <option value="bg-auto">Авто</option>
        <option value="bg-cover">Покрыть</option>
        <option value="bg-contain">Вписать</option>
    </select>
    <div class="mb-2" x-show="selectedElement && selectedElement.isImage">
        <label class="block text-gray-700 text-sm font-bold mb-2">Повтор фона:</label>
        <select x-model="selectedElement.backgroundRepeat" @change="applyBackgroundRepeat()">
            <option value="bg-repeat">Повторять</option>
            <option value="bg-no-repeat">Не повторять</option>
            <option value="bg-repeat-x">Повтор по горизонтали</option>
            <option value="bg-repeat-y">Повтор по вертикали</option>
            <option value="bg-repeat-round">Повтор кругом</option>
            <option value="bg-repeat-space">Повтор с промежутками</option>
        </select>
    </div>
    
    <div class="mb-2" x-show="selectedElement && selectedElement.isImage">
        <label class="block text-gray-700 text-sm font-bold mb-2">Размер фона:</label>
        <select x-model="selectedElement.backgroundSize" @change="applyBackgroundSize()">
            <option value="bg-auto">Автоматически</option>
            <option value="bg-cover">Покрыть</option>
            <option value="bg-contain">Содержать</option>
        </select>


    </div>
    
    <div class="mb-2" x-show="selectedElement && selectedElement.isImage">
        <label class="block text-gray-700 text-sm font-bold mb-2">Закрепление фона:</label>
        <select x-model="selectedElement.backgroundAttachment" @change="applyBackgroundAttachment()">
            <option value="bg-fixed">Закреплено</option>
            <option value="bg-local">Локально</option>
            <option value="bg-scroll">Прокрутка</option>
        </select>
    </div>

</div>
<div class="mb-4" x-show="selectedElement">
    <h4 class="text-md font-bold mb-2">Тени и скругления</h4>
    <div class="mb-2">
        <label class="block text-gray-700 text-sm font-bold mb-2" for="shadow">Тень:</label>
        <select id="shadow" x-model="selectedElement.shadow" @change="applyShadow()" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
            <option value="shadow-none">Без тени</option>
            <option value="shadow-sm">Маленькая тень</option>
            <option value="shadow">Стандартная тень</option>
            <option value="shadow-md">Средняя тень</option>
            <option value="shadow-lg">Большая тень</option>
            <option value="shadow-xl">Очень большая тень</option>
            <option value="shadow-2xl">Огромная тень</option>
        </select>
    </div>
    <div class="mb-2">
        <label class="block text-gray-700 text-sm font-bold mb-2" for="rounded">Скругление:</label>
        <select id="rounded" x-model="selectedElement.rounded" @change="applyRounded()" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
            <option value="rounded-none">Без скругления</option>
            <option value="rounded-sm">Маленькое скругление</option>
            <option value="rounded">Стандартное скругление</option>
            <option value="rounded-md">Среднее скругление</option>
            <option value="rounded-lg">Большое скругление</option>
            <option value="rounded-xl">Очень большое скругление</option>
            <option value="rounded-2xl">Огромное скругление</option>
            <option value="rounded-full">Полное скругление</option>
        </select>
    </div>
    <h4 class="text-md font-bold mb-2">Анимации</h4>
    <div class="mb-2">
        <label class="block text-gray-700 text-sm font-bold mb-2" for="animation">Анимация:</label>
        <select id="animation" x-model="selectedElement.animation" @change="applyAnimation()" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
            <option value="">Без анимации</option>
            <option value="animate-spin">Вращение</option>
            <option value="animate-ping">Пульсация</option>
            <option value="animate-pulse">Пульсация (мягкая)</option>
            <option value="animate-bounce">Прыжки</option>
            <option value="animate-fade">Появление</option>
            <option value="animate-slide">Слайд</option>
        </select>
    </div>
    <h4 class="text-md font-bold mb-2">Переходы и трансформации</h4>
    <div class="mb-2">
        <label class="block text-gray-700 text-sm font-bold mb-2" for="transition">Переход:</label>
        <select id="transition" x-model="selectedElement.transition" @change="applyTransition()" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
            <option value="">Без перехода</option>
            <option value="transition-none">Без перехода</option>
            <option value="transition-all">Все свойства</option>
            <option value="transition-opacity">Прозрачность</option>
            <option value="transition-transform">Трансформация</option>
        </select>
    </div>
    <div class="mb-2">
        <label class="block text-gray-700 text-sm font-bold mb-2" for="transform">Трансформация:</label>
        <select id="transform" x-model="selectedElement.transform" @change="applyTransform()" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
            <option value="">Без трансформации</option>
            <option value="transform-none">Без трансформации</option>
            <option value="transform rotate-45">Поворот на 45°</option>
            <option value="transform scale-110">Увеличение на 10%</option>
            <option value="transform translate-x-4">Сдвиг по X</option>
            <option value="transform translate-y-4">Сдвиг по Y</option>
        </select>
    </div>
</div>

// resources/views/partials/editor-main.blade.php
<main class="w-full p-4 overflow-y-auto editor"
      data-page-id="{{ $page->id }}"
      data-page-content='@json($page->content)'>
    <div id="page-content" class="border p-4"
         @dragover.prevent
         @drop="handleDrop($event)"
         x-html="pageContent"
         @mouseover="highlightElement($event)"
         @mouseout="removeHighlight($event)">
        <!-- Здесь будет контент страницы -->
        <template x-for="element in document.getElementById('page-content').querySelectorAll('[data-id]')" :key="element.dataset.id">
            <div :data-id="element.dataset.id" :data-type="element.dataset.type"
                 x-data="element.dataset.type === 'block' ? blockComponent : elementComponent"
                 draggable="true"
                 @dragstart="event.dataTransfer.setData('text/plain', 'element-' + element.dataset.id);"
                 @dragover.prevent
                 @drop.prevent>
                <template x-if="element.dataset.type === 'block'">
                   <div x-html="element.outerHTML"></div>
                </template>
                <template x-if="element.dataset.type === 'element'">
                    <div x-html="element.outerHTML"></div>
                </template>
            </div>
        </template>
    </div>
</main>

// resources/views/partials/editor-modal.blade.php
<div x-show="showModal" class="fixed z-50 inset-0 overflow-y-auto bg-gray-500 bg-opacity-75 flex items-center justify-center modal" style="display: none;">
    <div class="bg-white rounded-lg p-8 w-3/4 max-w-3xl">
        <h2 class="text-2xl font-bold mb-4">Редактирование HTML-кода</h2>
         <textarea x-model="modalCode" class="w-full h-96 border rounded p-2 mb-4"></textarea>
        <div class="flex justify-end">
           <button @click="applyCode()" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded mr-2">Применить</button>
             <button @click="showModal = false" class="bg-gray-300 hover:bg-gray-400 text-gray-700 font-bold py-2 px-4 rounded">Отмена</button>
        </div>
    </div>
</div>

// resources/views/partials/editor-sidebar.blade.php
<div x-data="{ showPanel:true, blocksOpen: true, elementsOpen: true, categoryOpen: {} }" class="leftPanel">
    <div class="absolute top-4 left-4 z-10">
        <button @click="showPanel = !showPanel"  x-show="!showPanel" class="bg-gray-500 hover:bg-gray-700 text-white font-bold p-2 rounded" >
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                <path stroke-linecap="round" stroke-linejoin="round" d="M9 6.75V15m6-6v8.25m-3-4.5h.00m0 6.75h.00"/>
            </svg>
        </button>
    </div>

    <aside class="w-80 bg-gray-100 p-4 border-r flex flex-col"  x-show="showPanel">
        <div class="mb-4">
            <button @click="savePage" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Сохранить</button>
            <button @click="previewPage" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded">Просмотр</button>
            <button @click="exportPage" class="bg-purple-500 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded">Экспорт</button>
            <button @click="showPanel = false" class="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded" x-text="showPanel ? 'Скрыть' : 'Показать'"></button>
        </div>
        <div class="mb-4">
            <h4 class="text-md font-bold mb-2">Режим адаптивности</h4>
            <div class="flex space-x-2">
                <button @click="setDeviceMode('desktop')" :class="{ 'bg-blue-500 text-white': deviceMode === 'desktop' }" class="px-2 py-1 rounded border">Десктоп</button>
                <button @click="setDeviceMode('tablet')" :class="{ 'bg-blue-500 text-white': deviceMode === 'tablet' }" class="px-2 py-1 rounded border">Планшет</button>
                <button @click="setDeviceMode('mobile')" :class="{ 'bg-blue-500 text-white': deviceMode === 'mobile' }" class="px-2 py-1 rounded border">Мобильный</button>
            </div>
        </div>
        <div class="mb-4">
            <h4 class="text-md font-bold mb-2">Шаблоны</h4>
            <div class="space-y-2">
                <button @click="saveTemplate()" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">Сохранить как шаблон</button>
                <select x-model="selectedTemplate" @change="applyTemplate()" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                    <option value="">Выберите шаблон</option>
                    @foreach($templates as $template)
                        <option value="{{ $template->id }}">{{ $template->name }}</option>
                    @endforeach
                </select>
            </div>
        </div>
        <div class="flex-1 overflow-y-auto">
            <div class="mb-6">
                <h2 class="text-lg font-bold mb-2 flex items-center justify-between cursor-pointer" @click="blocksOpen = !blocksOpen">
                    <span >Блоки</span>
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4" :class="{'rotate-180': blocksOpen}">
                        <path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" />
                    </svg>
                </h2>
                <div x-show="blocksOpen" class="space-y-2">
                    @foreach($categories as $category)
                        @if($category->onlyBlocks->count() > 0)
                            <div class="mb-2">
                                <h3 class="text-md font-bold mb-2 flex items-center justify-between cursor-pointer" @click="categoryOpen['blocks_{{ $category->id }}'] = !categoryOpen['blocks_{{ $category->id }}']">
                                    <span class="flex items-center">
                                        {{ $category->title }}
                                        <span class="ml-2 bg-gray-200 text-gray-700 text-xs font-semibold py-0.5 px-2 rounded-full">{{ $category->onlyBlocks->count() }}</span>
                                    </span>
                                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4" :class="{'rotate-180': categoryOpen['blocks_{{ $category->id }}']}">
                                            <path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" />
                                        </svg>
                                </h3>
                                <div class="flex flex-wrap gap-2" x-show="categoryOpen['blocks_{{ $category->id }}']" >
                                    @foreach($category->onlyBlocks as $block)
                                        <div class="p-2 border rounded cursor-pointer"
                                             draggable="true"
                                             @dragstart="isDragging = true; $event.dataTransfer.setData('text/plain', 'block-{{ $block->id }}')"
                                        >
                                            <img src="{{ $block->preview ? asset('storage/' . $block->preview) : 'https://placehold.co/50x50'}}" alt="{{ $block->title }}" class="w-16 h-16 object-cover mb-2">
                                            {{ $block->title }}
                                        </div>
                                    @endforeach
                                </div>
                            </div>
                        @endif
                    @endforeach
                </div>
            </div>
            <div class="border-t my-4"></div>
            <div class="mb-6">
                <h2 class="text-lg font-bold mb-2 flex items-center justify-between cursor-pointer" @click="elementsOpen = !elementsOpen">
                    <span>Элементы</span>
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4" :class="{'rotate-180': elementsOpen}">
                        <path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" />
                    </svg>
                </h2>
                <div x-show="elementsOpen" class="space-y-2">
                    @foreach($categories as $category)
                        @if($category->elements->count() > 0)
                            <div class="mb-2">
                                <h3 class="text-md font-bold mb-2 flex items-center justify-between cursor-pointer" @click="categoryOpen['elements_{{ $category->id }}'] = !categoryOpen['elements_{{ $category->id }}']">
                                    <span class="flex items-center">
                                        {{ $category->title }}
                                        <span class="ml-2 bg-gray-200 text-gray-700 text-xs font-semibold py-0.5 px-2 rounded-full">{{ $category->elements->count() }}</span>
                                    </span>
                                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4" :class="{'rotate-180': categoryOpen['elements_{{ $category->id }}']}">
                                            <path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" />
                                        </svg>
                                </h3>
                                <div class="flex flex-wrap gap-2" x-show="categoryOpen['elements_{{ $category->id }}']">
                                    @foreach($category->elements as $element)
                                        <div class="p-2 border rounded cursor-pointer"
                                             draggable="true"
                                            @dragstart="isDragging = true; $event.dataTransfer.setData('text/plain', 'element-{{ $element->id }}')"
                                        >
                                            <img src="{{ $element->preview ? asset('storage/' . $element->preview) : 'https://placehold.co/50x50' }}" alt="{{ $element->title }}" class="w-16 h-16 object-cover mb-2">
                                            {{ $element->title }}
                                        </div>
                                    @endforeach
                                </div>
                            </div>
                        @endif
                    @endforeach
                </div>
            </div>
        </div>
    </aside>
</div>

// resources/views/editor.blade.php
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Визуальный редактор</title>
    @vite(['resources/css/app.css'])
    <script src="https://cdn.tailwindcss.com"></script>
    @vite('resources/js/app.js')
</head>
<body>
<div class="flex h-screen"
     x-data="editor()"
     x-init="init()">
    @include('partials.editor-sidebar')
    @include('partials.editor-main')
    
    <!-- Блок с x-data="elementEditor()" -->
    <div
         
         x-data="elementEditor()">
        <div x-show="Alpine.store('editorStore').showPanel" class="bg-white p-4 border-l w-96 absolute top-0 right-0 h-full overflow-y-auto panel-right" style="display: none;">
            @include('partials.editor-element-panel')
        </div>
        
        <!-- Перемещаем модальное окно сюда -->
        @include('partials.editor-modal')
        @include('partials.media-manager')
    </div>
</div>
</body>
</html>

// resources/views/export.blade.php
{!! $processedContent !!}

// resources/views/preview.blade.php
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>{{ $page->seo_title ?? $page->title }}</title>
    @if($page->custom_css_classes)
        <style>
            {{ $page->custom_css_classes }}
        </style>
    @endif
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="/lightbox/dist/css/lightbox.min.css">
</head>
<body>
{!! $processedContent !!}
@if($page->custom_js_code)
    <script>
        {{ $page->custom_js_code }}
    </script>
@endif

<script src="/lightbox/dist/js/lightbox-plus-jquery.min.js"></script>
</body>
</html>

